{"ast":null,"code":"import find from \"../polyfills/find.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { isNode } from \"../language/ast.mjs\";\nimport { getVisitFn } from \"../language/visitor.mjs\";\nimport { isObjectType, isInterfaceType, isEnumType, isInputObjectType, isListType, isCompositeType, isInputType, isOutputType, getNullableType, getNamedType } from \"../type/definition.mjs\";\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from \"../type/introspection.mjs\";\nimport { typeFromAST } from \"./typeFromAST.mjs\";\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\n\nexport var TypeInfo = /*#__PURE__*/function () {\n  function TypeInfo(schema, // NOTE: this experimental optional second parameter is only needed in order\n  // to support non-spec-compliant code bases. You should never need to use it.\n  // It may disappear in the future.\n  getFieldDefFn, // Initial type may be provided in rare cases to facilitate traversals\n  // beginning somewhere other than documents.\n  initialType) {\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;\n\n    if (initialType) {\n      if (isInputType(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if (isCompositeType(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if (isOutputType(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  var _proto = TypeInfo.prototype;\n\n  _proto.getType = function getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  };\n\n  _proto.getParentType = function getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  };\n\n  _proto.getInputType = function getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  };\n\n  _proto.getParentInputType = function getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  };\n\n  _proto.getFieldDef = function getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  };\n\n  _proto.getDefaultValue = function getDefaultValue() {\n    if (this._defaultValueStack.length > 0) {\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\n    }\n  };\n\n  _proto.getDirective = function getDirective() {\n    return this._directive;\n  };\n\n  _proto.getArgument = function getArgument() {\n    return this._argument;\n  };\n\n  _proto.getEnumValue = function getEnumValue() {\n    return this._enumValue;\n  };\n\n  _proto.enter = function enter(node) {\n    var schema = this._schema; // Note: many of the types below are explicitly typed as \"mixed\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        {\n          var namedType = getNamedType(this.getType());\n\n          this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);\n\n          break;\n        }\n\n      case Kind.FIELD:\n        {\n          var parentType = this.getParentType();\n          var fieldDef;\n          var fieldType;\n\n          if (parentType) {\n            fieldDef = this._getFieldDef(schema, parentType, node);\n\n            if (fieldDef) {\n              fieldType = fieldDef.type;\n            }\n          }\n\n          this._fieldDefStack.push(fieldDef);\n\n          this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);\n\n          break;\n        }\n\n      case Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n        {\n          var type;\n\n          switch (node.operation) {\n            case 'query':\n              type = schema.getQueryType();\n              break;\n\n            case 'mutation':\n              type = schema.getMutationType();\n              break;\n\n            case 'subscription':\n              type = schema.getSubscriptionType();\n              break;\n          }\n\n          this._typeStack.push(isObjectType(type) ? type : undefined);\n\n          break;\n        }\n\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        {\n          var typeConditionAST = node.typeCondition;\n          var outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());\n\n          this._typeStack.push(isOutputType(outputType) ? outputType : undefined);\n\n          break;\n        }\n\n      case Kind.VARIABLE_DEFINITION:\n        {\n          var inputType = typeFromAST(schema, node.type);\n\n          this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);\n\n          break;\n        }\n\n      case Kind.ARGUMENT:\n        {\n          var _this$getDirective;\n\n          var argDef;\n          var argType;\n          var fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();\n\n          if (fieldOrDirective) {\n            argDef = find(fieldOrDirective.args, function (arg) {\n              return arg.name === node.name.value;\n            });\n\n            if (argDef) {\n              argType = argDef.type;\n            }\n          }\n\n          this._argument = argDef;\n\n          this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n\n          this._inputTypeStack.push(isInputType(argType) ? argType : undefined);\n\n          break;\n        }\n\n      case Kind.LIST:\n        {\n          var listType = getNullableType(this.getInputType());\n          var itemType = isListType(listType) ? listType.ofType : listType; // List positions never have a default value.\n\n          this._defaultValueStack.push(undefined);\n\n          this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);\n\n          break;\n        }\n\n      case Kind.OBJECT_FIELD:\n        {\n          var objectType = getNamedType(this.getInputType());\n          var inputFieldType;\n          var inputField;\n\n          if (isInputObjectType(objectType)) {\n            inputField = objectType.getFields()[node.name.value];\n\n            if (inputField) {\n              inputFieldType = inputField.type;\n            }\n          }\n\n          this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);\n\n          this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);\n\n          break;\n        }\n\n      case Kind.ENUM:\n        {\n          var enumType = getNamedType(this.getInputType());\n          var enumValue;\n\n          if (isEnumType(enumType)) {\n            enumValue = enumType.getValue(node.value);\n          }\n\n          this._enumValue = enumValue;\n          break;\n        }\n    }\n  };\n\n  _proto.leave = function leave(node) {\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ARGUMENT:\n        this._argument = null;\n\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.LIST:\n      case Kind.OBJECT_FIELD:\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ENUM:\n        this._enumValue = null;\n        break;\n    }\n  };\n\n  return TypeInfo;\n}();\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n\n  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  }\n\n  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  }\n\n  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\n    return TypeNameMetaFieldDef;\n  }\n\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\n    return parentType.getFields()[name];\n  }\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\n\nexport function visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      false);\n\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      true);\n      var result;\n\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}","map":{"version":3,"names":["find","Kind","isNode","getVisitFn","isObjectType","isInterfaceType","isEnumType","isInputObjectType","isListType","isCompositeType","isInputType","isOutputType","getNullableType","getNamedType","SchemaMetaFieldDef","TypeMetaFieldDef","TypeNameMetaFieldDef","typeFromAST","TypeInfo","schema","getFieldDefFn","initialType","_schema","_typeStack","_parentTypeStack","_inputTypeStack","_fieldDefStack","_defaultValueStack","_directive","_argument","_enumValue","_getFieldDef","getFieldDef","push","_proto","prototype","getType","length","getParentType","getInputType","getParentInputType","getDefaultValue","getDirective","getArgument","getEnumValue","enter","node","kind","SELECTION_SET","namedType","undefined","FIELD","parentType","fieldDef","fieldType","type","DIRECTIVE","name","value","OPERATION_DEFINITION","operation","getQueryType","getMutationType","getSubscriptionType","INLINE_FRAGMENT","FRAGMENT_DEFINITION","typeConditionAST","typeCondition","outputType","VARIABLE_DEFINITION","inputType","ARGUMENT","_this$getDirective","argDef","argType","fieldOrDirective","args","arg","defaultValue","LIST","listType","itemType","ofType","OBJECT_FIELD","objectType","inputFieldType","inputField","getFields","ENUM","enumType","enumValue","getValue","leave","pop","fieldNode","visitWithTypeInfo","typeInfo","visitor","fn","result","apply","arguments"],"sources":["C:/Users/jleig/Desktop/challenges/dream-small/client/node_modules/graphql/utilities/TypeInfo.mjs"],"sourcesContent":["import find from \"../polyfills/find.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { isNode } from \"../language/ast.mjs\";\nimport { getVisitFn } from \"../language/visitor.mjs\";\nimport { isObjectType, isInterfaceType, isEnumType, isInputObjectType, isListType, isCompositeType, isInputType, isOutputType, getNullableType, getNamedType } from \"../type/definition.mjs\";\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from \"../type/introspection.mjs\";\nimport { typeFromAST } from \"./typeFromAST.mjs\";\n/**\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\n * of the current field and type definitions at any point in a GraphQL document\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\n */\n\nexport var TypeInfo = /*#__PURE__*/function () {\n  function TypeInfo(schema, // NOTE: this experimental optional second parameter is only needed in order\n  // to support non-spec-compliant code bases. You should never need to use it.\n  // It may disappear in the future.\n  getFieldDefFn, // Initial type may be provided in rare cases to facilitate traversals\n  // beginning somewhere other than documents.\n  initialType) {\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;\n\n    if (initialType) {\n      if (isInputType(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if (isCompositeType(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if (isOutputType(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  var _proto = TypeInfo.prototype;\n\n  _proto.getType = function getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  };\n\n  _proto.getParentType = function getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  };\n\n  _proto.getInputType = function getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  };\n\n  _proto.getParentInputType = function getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  };\n\n  _proto.getFieldDef = function getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  };\n\n  _proto.getDefaultValue = function getDefaultValue() {\n    if (this._defaultValueStack.length > 0) {\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\n    }\n  };\n\n  _proto.getDirective = function getDirective() {\n    return this._directive;\n  };\n\n  _proto.getArgument = function getArgument() {\n    return this._argument;\n  };\n\n  _proto.getEnumValue = function getEnumValue() {\n    return this._enumValue;\n  };\n\n  _proto.enter = function enter(node) {\n    var schema = this._schema; // Note: many of the types below are explicitly typed as \"mixed\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        {\n          var namedType = getNamedType(this.getType());\n\n          this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);\n\n          break;\n        }\n\n      case Kind.FIELD:\n        {\n          var parentType = this.getParentType();\n          var fieldDef;\n          var fieldType;\n\n          if (parentType) {\n            fieldDef = this._getFieldDef(schema, parentType, node);\n\n            if (fieldDef) {\n              fieldType = fieldDef.type;\n            }\n          }\n\n          this._fieldDefStack.push(fieldDef);\n\n          this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);\n\n          break;\n        }\n\n      case Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n        {\n          var type;\n\n          switch (node.operation) {\n            case 'query':\n              type = schema.getQueryType();\n              break;\n\n            case 'mutation':\n              type = schema.getMutationType();\n              break;\n\n            case 'subscription':\n              type = schema.getSubscriptionType();\n              break;\n          }\n\n          this._typeStack.push(isObjectType(type) ? type : undefined);\n\n          break;\n        }\n\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        {\n          var typeConditionAST = node.typeCondition;\n          var outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());\n\n          this._typeStack.push(isOutputType(outputType) ? outputType : undefined);\n\n          break;\n        }\n\n      case Kind.VARIABLE_DEFINITION:\n        {\n          var inputType = typeFromAST(schema, node.type);\n\n          this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);\n\n          break;\n        }\n\n      case Kind.ARGUMENT:\n        {\n          var _this$getDirective;\n\n          var argDef;\n          var argType;\n          var fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();\n\n          if (fieldOrDirective) {\n            argDef = find(fieldOrDirective.args, function (arg) {\n              return arg.name === node.name.value;\n            });\n\n            if (argDef) {\n              argType = argDef.type;\n            }\n          }\n\n          this._argument = argDef;\n\n          this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n\n          this._inputTypeStack.push(isInputType(argType) ? argType : undefined);\n\n          break;\n        }\n\n      case Kind.LIST:\n        {\n          var listType = getNullableType(this.getInputType());\n          var itemType = isListType(listType) ? listType.ofType : listType; // List positions never have a default value.\n\n          this._defaultValueStack.push(undefined);\n\n          this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);\n\n          break;\n        }\n\n      case Kind.OBJECT_FIELD:\n        {\n          var objectType = getNamedType(this.getInputType());\n          var inputFieldType;\n          var inputField;\n\n          if (isInputObjectType(objectType)) {\n            inputField = objectType.getFields()[node.name.value];\n\n            if (inputField) {\n              inputFieldType = inputField.type;\n            }\n          }\n\n          this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);\n\n          this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);\n\n          break;\n        }\n\n      case Kind.ENUM:\n        {\n          var enumType = getNamedType(this.getInputType());\n          var enumValue;\n\n          if (isEnumType(enumType)) {\n            enumValue = enumType.getValue(node.value);\n          }\n\n          this._enumValue = enumValue;\n          break;\n        }\n    }\n  };\n\n  _proto.leave = function leave(node) {\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ARGUMENT:\n        this._argument = null;\n\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.LIST:\n      case Kind.OBJECT_FIELD:\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ENUM:\n        this._enumValue = null;\n        break;\n    }\n  };\n\n  return TypeInfo;\n}();\n/**\n * Not exactly the same as the executor's definition of getFieldDef, in this\n * statically evaluated environment we do not always have an Object type,\n * and need to handle Interface and Union types.\n */\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  var name = fieldNode.name.value;\n\n  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  }\n\n  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  }\n\n  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\n    return TypeNameMetaFieldDef;\n  }\n\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\n    return parentType.getFields()[name];\n  }\n}\n/**\n * Creates a new visitor instance which maintains a provided TypeInfo instance\n * along with visiting visitor.\n */\n\n\nexport function visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter: function enter(node) {\n      typeInfo.enter(node);\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      false);\n\n      if (fn) {\n        var result = fn.apply(visitor, arguments);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n    leave: function leave(node) {\n      var fn = getVisitFn(visitor, node.kind,\n      /* isLeaving */\n      true);\n      var result;\n\n      if (fn) {\n        result = fn.apply(visitor, arguments);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}