{"ast":null,"code":"import { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { keyMap } from '../jsutils/keyMap.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { isInputObjectType, isLeafType, isListType, isNonNullType } from '../type/definition.mjs';\n/**\r\n * Produces a JavaScript value given a GraphQL Value AST.\r\n *\r\n * A GraphQL type must be provided, which will be used to interpret different\r\n * GraphQL Value literals.\r\n *\r\n * Returns `undefined` when the value could not be validly coerced according to\r\n * the provided type.\r\n *\r\n * | GraphQL Value        | JSON Value    |\r\n * | -------------------- | ------------- |\r\n * | Input Object         | Object        |\r\n * | List                 | Array         |\r\n * | Boolean              | Boolean       |\r\n * | String               | String        |\r\n * | Int / Float          | Number        |\r\n * | Enum Value           | Unknown       |\r\n * | NullValue            | null          |\r\n *\r\n */\n\nexport function valueFromAST(valueNode, type, variables) {\n  if (!valueNode) {\n    // When there is no node, then there is also no value.\n    // Importantly, this is different from returning the value null.\n    return;\n  }\n\n  if (valueNode.kind === Kind.VARIABLE) {\n    const variableName = valueNode.name.value;\n\n    if (variables == null || variables[variableName] === undefined) {\n      // No valid return value.\n      return;\n    }\n\n    const variableValue = variables[variableName];\n\n    if (variableValue === null && isNonNullType(type)) {\n      return; // Invalid: intentionally return no value.\n    } // Note: This does no further checking that this variable is correct.\n    // This assumes that this query has been validated and the variable\n    // usage here is of the correct type.\n\n\n    return variableValue;\n  }\n\n  if (isNonNullType(type)) {\n    if (valueNode.kind === Kind.NULL) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return valueFromAST(valueNode, type.ofType, variables);\n  }\n\n  if (valueNode.kind === Kind.NULL) {\n    // This is explicitly returning the value null.\n    return null;\n  }\n\n  if (isListType(type)) {\n    const itemType = type.ofType;\n\n    if (valueNode.kind === Kind.LIST) {\n      const coercedValues = [];\n\n      for (const itemNode of valueNode.values) {\n        if (isMissingVariable(itemNode, variables)) {\n          // If an array contains a missing variable, it is either coerced to\n          // null or if the item type is non-null, it considered invalid.\n          if (isNonNullType(itemType)) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(null);\n        } else {\n          const itemValue = valueFromAST(itemNode, itemType, variables);\n\n          if (itemValue === undefined) {\n            return; // Invalid: intentionally return no value.\n          }\n\n          coercedValues.push(itemValue);\n        }\n      }\n\n      return coercedValues;\n    }\n\n    const coercedValue = valueFromAST(valueNode, itemType, variables);\n\n    if (coercedValue === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return [coercedValue];\n  }\n\n  if (isInputObjectType(type)) {\n    if (valueNode.kind !== Kind.OBJECT) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    const coercedObj = Object.create(null);\n    const fieldNodes = keyMap(valueNode.fields, field => field.name.value);\n\n    for (const field of Object.values(type.getFields())) {\n      const fieldNode = fieldNodes[field.name];\n\n      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {\n        if (field.defaultValue !== undefined) {\n          coercedObj[field.name] = field.defaultValue;\n        } else if (isNonNullType(field.type)) {\n          return; // Invalid: intentionally return no value.\n        }\n\n        continue;\n      }\n\n      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);\n\n      if (fieldValue === undefined) {\n        return; // Invalid: intentionally return no value.\n      }\n\n      coercedObj[field.name] = fieldValue;\n    }\n\n    return coercedObj;\n  }\n\n  if (isLeafType(type)) {\n    // Scalars and Enums fulfill parsing a literal value via parseLiteral().\n    // Invalid values represent a failure to parse correctly, in which case\n    // no value is returned.\n    let result;\n\n    try {\n      result = type.parseLiteral(valueNode, variables);\n    } catch (_error) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    if (result === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n\n    return result;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible input types have been considered.\n\n\n  false || invariant(false, 'Unexpected input type: ' + inspect(type));\n} // Returns true if the provided valueNode is a variable which is not defined\n// in the set of variables.\n\nfunction isMissingVariable(valueNode, variables) {\n  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === undefined);\n}","map":{"version":3,"names":["inspect","invariant","keyMap","Kind","isInputObjectType","isLeafType","isListType","isNonNullType","valueFromAST","valueNode","type","variables","kind","VARIABLE","variableName","name","value","undefined","variableValue","NULL","ofType","itemType","LIST","coercedValues","itemNode","values","isMissingVariable","push","itemValue","coercedValue","OBJECT","coercedObj","Object","create","fieldNodes","fields","field","getFields","fieldNode","defaultValue","fieldValue","result","parseLiteral","_error"],"sources":["C:/Users/Dani/Desktop/projects/dream-small/dream-small/node_modules/graphql/utilities/valueFromAST.mjs"],"sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\r\nimport { invariant } from '../jsutils/invariant.mjs';\r\nimport { keyMap } from '../jsutils/keyMap.mjs';\r\nimport { Kind } from '../language/kinds.mjs';\r\nimport {\r\n  isInputObjectType,\r\n  isLeafType,\r\n  isListType,\r\n  isNonNullType,\r\n} from '../type/definition.mjs';\r\n/**\r\n * Produces a JavaScript value given a GraphQL Value AST.\r\n *\r\n * A GraphQL type must be provided, which will be used to interpret different\r\n * GraphQL Value literals.\r\n *\r\n * Returns `undefined` when the value could not be validly coerced according to\r\n * the provided type.\r\n *\r\n * | GraphQL Value        | JSON Value    |\r\n * | -------------------- | ------------- |\r\n * | Input Object         | Object        |\r\n * | List                 | Array         |\r\n * | Boolean              | Boolean       |\r\n * | String               | String        |\r\n * | Int / Float          | Number        |\r\n * | Enum Value           | Unknown       |\r\n * | NullValue            | null          |\r\n *\r\n */\r\n\r\nexport function valueFromAST(valueNode, type, variables) {\r\n  if (!valueNode) {\r\n    // When there is no node, then there is also no value.\r\n    // Importantly, this is different from returning the value null.\r\n    return;\r\n  }\r\n\r\n  if (valueNode.kind === Kind.VARIABLE) {\r\n    const variableName = valueNode.name.value;\r\n\r\n    if (variables == null || variables[variableName] === undefined) {\r\n      // No valid return value.\r\n      return;\r\n    }\r\n\r\n    const variableValue = variables[variableName];\r\n\r\n    if (variableValue === null && isNonNullType(type)) {\r\n      return; // Invalid: intentionally return no value.\r\n    } // Note: This does no further checking that this variable is correct.\r\n    // This assumes that this query has been validated and the variable\r\n    // usage here is of the correct type.\r\n\r\n    return variableValue;\r\n  }\r\n\r\n  if (isNonNullType(type)) {\r\n    if (valueNode.kind === Kind.NULL) {\r\n      return; // Invalid: intentionally return no value.\r\n    }\r\n\r\n    return valueFromAST(valueNode, type.ofType, variables);\r\n  }\r\n\r\n  if (valueNode.kind === Kind.NULL) {\r\n    // This is explicitly returning the value null.\r\n    return null;\r\n  }\r\n\r\n  if (isListType(type)) {\r\n    const itemType = type.ofType;\r\n\r\n    if (valueNode.kind === Kind.LIST) {\r\n      const coercedValues = [];\r\n\r\n      for (const itemNode of valueNode.values) {\r\n        if (isMissingVariable(itemNode, variables)) {\r\n          // If an array contains a missing variable, it is either coerced to\r\n          // null or if the item type is non-null, it considered invalid.\r\n          if (isNonNullType(itemType)) {\r\n            return; // Invalid: intentionally return no value.\r\n          }\r\n\r\n          coercedValues.push(null);\r\n        } else {\r\n          const itemValue = valueFromAST(itemNode, itemType, variables);\r\n\r\n          if (itemValue === undefined) {\r\n            return; // Invalid: intentionally return no value.\r\n          }\r\n\r\n          coercedValues.push(itemValue);\r\n        }\r\n      }\r\n\r\n      return coercedValues;\r\n    }\r\n\r\n    const coercedValue = valueFromAST(valueNode, itemType, variables);\r\n\r\n    if (coercedValue === undefined) {\r\n      return; // Invalid: intentionally return no value.\r\n    }\r\n\r\n    return [coercedValue];\r\n  }\r\n\r\n  if (isInputObjectType(type)) {\r\n    if (valueNode.kind !== Kind.OBJECT) {\r\n      return; // Invalid: intentionally return no value.\r\n    }\r\n\r\n    const coercedObj = Object.create(null);\r\n    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);\r\n\r\n    for (const field of Object.values(type.getFields())) {\r\n      const fieldNode = fieldNodes[field.name];\r\n\r\n      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {\r\n        if (field.defaultValue !== undefined) {\r\n          coercedObj[field.name] = field.defaultValue;\r\n        } else if (isNonNullType(field.type)) {\r\n          return; // Invalid: intentionally return no value.\r\n        }\r\n\r\n        continue;\r\n      }\r\n\r\n      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);\r\n\r\n      if (fieldValue === undefined) {\r\n        return; // Invalid: intentionally return no value.\r\n      }\r\n\r\n      coercedObj[field.name] = fieldValue;\r\n    }\r\n\r\n    return coercedObj;\r\n  }\r\n\r\n  if (isLeafType(type)) {\r\n    // Scalars and Enums fulfill parsing a literal value via parseLiteral().\r\n    // Invalid values represent a failure to parse correctly, in which case\r\n    // no value is returned.\r\n    let result;\r\n\r\n    try {\r\n      result = type.parseLiteral(valueNode, variables);\r\n    } catch (_error) {\r\n      return; // Invalid: intentionally return no value.\r\n    }\r\n\r\n    if (result === undefined) {\r\n      return; // Invalid: intentionally return no value.\r\n    }\r\n\r\n    return result;\r\n  }\r\n  /* c8 ignore next 3 */\r\n  // Not reachable, all possible input types have been considered.\r\n\r\n  false || invariant(false, 'Unexpected input type: ' + inspect(type));\r\n} // Returns true if the provided valueNode is a variable which is not defined\r\n// in the set of variables.\r\n\r\nfunction isMissingVariable(valueNode, variables) {\r\n  return (\r\n    valueNode.kind === Kind.VARIABLE &&\r\n    (variables == null || variables[valueNode.name.value] === undefined)\r\n  );\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}