{"ast":null,"code":"import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { invariant } from '../jsutils/invariant.mjs';\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { isPromise } from '../jsutils/isPromise.mjs';\nimport { memoize3 } from '../jsutils/memoize3.mjs';\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\nimport { promiseForObject } from '../jsutils/promiseForObject.mjs';\nimport { promiseReduce } from '../jsutils/promiseReduce.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { locatedError } from '../error/locatedError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { isAbstractType, isLeafType, isListType, isNonNullType, isObjectType } from '../type/definition.mjs';\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from '../type/introspection.mjs';\nimport { assertValidSchema } from '../type/validate.mjs';\nimport { collectFields, collectSubfields as _collectSubfields } from './collectFields.mjs';\nimport { getArgumentValues, getVariableValues } from './values.mjs';\n/**\r\n * A memoized collection of relevant subfields with regard to the return\r\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\r\n * saves overhead when resolving lists of values.\r\n */\n\nconst collectSubfields = memoize3((exeContext, returnType, fieldNodes) => _collectSubfields(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));\n/**\r\n * Terminology\r\n *\r\n * \"Definitions\" are the generic name for top-level statements in the document.\r\n * Examples of this include:\r\n * 1) Operations (such as a query)\r\n * 2) Fragments\r\n *\r\n * \"Operations\" are a generic name for requests in the document.\r\n * Examples of this include:\r\n * 1) query,\r\n * 2) mutation\r\n *\r\n * \"Selections\" are the definitions that can appear legally and at\r\n * single level of the query. These include:\r\n * 1) field references e.g `a`\r\n * 2) fragment \"spreads\" e.g. `...c`\r\n * 3) inline fragment \"spreads\" e.g. `...on Type { a }`\r\n */\n\n/**\r\n * Data that must be available at all points during query execution.\r\n *\r\n * Namely, schema of the type system that is currently executing,\r\n * and the fragments defined in the query document\r\n */\n\n/**\r\n * Implements the \"Executing requests\" section of the GraphQL specification.\r\n *\r\n * Returns either a synchronous ExecutionResult (if all encountered resolvers\r\n * are synchronous), or a Promise of an ExecutionResult that will eventually be\r\n * resolved and never rejected.\r\n *\r\n * If the arguments to this function do not result in a legal execution context,\r\n * a GraphQLError will be thrown immediately explaining the invalid input.\r\n */\n\nexport function execute(args) {\n  // Temporary for v15 to v16 migration. Remove in v17\n  arguments.length < 2 || devAssert(false, 'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.');\n  const {\n    schema,\n    document,\n    variableValues,\n    rootValue\n  } = args; // If arguments are missing or incorrect, throw an error.\n\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n\n  const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\n\n  if (!('schema' in exeContext)) {\n    return {\n      errors: exeContext\n    };\n  } // Return a Promise that will eventually resolve to the data described by\n  // The \"Response\" section of the GraphQL specification.\n  //\n  // If errors are encountered while executing a GraphQL field, only that\n  // field and its descendants will be omitted, and sibling fields will still\n  // be executed. An execution which encounters errors will still result in a\n  // resolved Promise.\n  //\n  // Errors from sub-fields of a NonNull type may propagate to the top level,\n  // at which point we still log the error and null the parent field, which\n  // in this case is the entire response.\n\n\n  try {\n    const {\n      operation\n    } = exeContext;\n    const result = executeOperation(exeContext, operation, rootValue);\n\n    if (isPromise(result)) {\n      return result.then(data => buildResponse(data, exeContext.errors), error => {\n        exeContext.errors.push(error);\n        return buildResponse(null, exeContext.errors);\n      });\n    }\n\n    return buildResponse(result, exeContext.errors);\n  } catch (error) {\n    exeContext.errors.push(error);\n    return buildResponse(null, exeContext.errors);\n  }\n}\n/**\r\n * Also implements the \"Executing requests\" section of the GraphQL specification.\r\n * However, it guarantees to complete synchronously (or throw an error) assuming\r\n * that all field resolvers are also synchronous.\r\n */\n\nexport function executeSync(args) {\n  const result = execute(args); // Assert that the execution was synchronous.\n\n  if (isPromise(result)) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n/**\r\n * Given a completed execution context and data, build the `{ errors, data }`\r\n * response defined by the \"Response\" section of the GraphQL specification.\r\n */\n\nfunction buildResponse(data, errors) {\n  return errors.length === 0 ? {\n    data\n  } : {\n    errors,\n    data\n  };\n}\n/**\r\n * Essential assertions before executing to provide developer feedback for\r\n * improper use of the GraphQL library.\r\n *\r\n * @internal\r\n */\n\n\nexport function assertValidExecutionArguments(schema, document, rawVariableValues) {\n  document || devAssert(false, 'Must provide document.'); // If the schema used for execution is invalid, throw an error.\n\n  assertValidSchema(schema); // Variables, if provided, must be an object.\n\n  rawVariableValues == null || isObjectLike(rawVariableValues) || devAssert(false, 'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.');\n}\n/**\r\n * Constructs a ExecutionContext object from the arguments passed to\r\n * execute, which we will pass throughout the other execution methods.\r\n *\r\n * Throws a GraphQLError if a valid execution context cannot be created.\r\n *\r\n * @internal\r\n */\n\nexport function buildExecutionContext(args) {\n  var _definition$name, _operation$variableDe;\n\n  const {\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues: rawVariableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n    subscribeFieldResolver\n  } = args;\n  let operation;\n  const fragments = Object.create(null);\n\n  for (const definition of document.definitions) {\n    switch (definition.kind) {\n      case Kind.OPERATION_DEFINITION:\n        if (operationName == null) {\n          if (operation !== undefined) {\n            return [new GraphQLError('Must provide operation name if query contains multiple operations.')];\n          }\n\n          operation = definition;\n        } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {\n          operation = definition;\n        }\n\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n\n      default: // ignore non-executable definitions\n\n    }\n  }\n\n  if (!operation) {\n    if (operationName != null) {\n      return [new GraphQLError(`Unknown operation named \"${operationName}\".`)];\n    }\n\n    return [new GraphQLError('Must provide an operation.')];\n  } // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  /* c8 ignore next */\n\n\n  const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];\n  const coercedVariableValues = getVariableValues(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {}, {\n    maxErrors: 50\n  });\n\n  if (coercedVariableValues.errors) {\n    return coercedVariableValues.errors;\n  }\n\n  return {\n    schema,\n    fragments,\n    rootValue,\n    contextValue,\n    operation,\n    variableValues: coercedVariableValues.coerced,\n    fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,\n    typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,\n    subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,\n    errors: []\n  };\n}\n/**\r\n * Implements the \"Executing operations\" section of the spec.\r\n */\n\nfunction executeOperation(exeContext, operation, rootValue) {\n  const rootType = exeContext.schema.getRootType(operation.operation);\n\n  if (rootType == null) {\n    throw new GraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {\n      nodes: operation\n    });\n  }\n\n  const rootFields = collectFields(exeContext.schema, exeContext.fragments, exeContext.variableValues, rootType, operation.selectionSet);\n  const path = undefined;\n\n  switch (operation.operation) {\n    case OperationTypeNode.QUERY:\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n\n    case OperationTypeNode.MUTATION:\n      return executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);\n\n    case OperationTypeNode.SUBSCRIPTION:\n      // TODO: deprecate `subscribe` and move all logic here\n      // Temporary solution until we finish merging execute and subscribe together\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\n  }\n}\n/**\r\n * Implements the \"Executing selection sets\" section of the spec\r\n * for fields that must be executed serially.\r\n */\n\n\nfunction executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {\n  return promiseReduce(fields.entries(), (results, _ref) => {\n    let [responseName, fieldNodes] = _ref;\n    const fieldPath = addPath(path, responseName, parentType.name);\n    const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);\n\n    if (result === undefined) {\n      return results;\n    }\n\n    if (isPromise(result)) {\n      return result.then(resolvedResult => {\n        results[responseName] = resolvedResult;\n        return results;\n      });\n    }\n\n    results[responseName] = result;\n    return results;\n  }, Object.create(null));\n}\n/**\r\n * Implements the \"Executing selection sets\" section of the spec\r\n * for fields that may be executed in parallel.\r\n */\n\n\nfunction executeFields(exeContext, parentType, sourceValue, path, fields) {\n  const results = Object.create(null);\n  let containsPromise = false;\n\n  for (const [responseName, fieldNodes] of fields.entries()) {\n    const fieldPath = addPath(path, responseName, parentType.name);\n    const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);\n\n    if (result !== undefined) {\n      results[responseName] = result;\n\n      if (isPromise(result)) {\n        containsPromise = true;\n      }\n    }\n  } // If there are no promises, we can just return the object\n\n\n  if (!containsPromise) {\n    return results;\n  } // Otherwise, results is a map from field name to the result of resolving that\n  // field, which is possibly a promise. Return a promise that will return this\n  // same map, but with any promises replaced with the values they resolved to.\n\n\n  return promiseForObject(results);\n}\n/**\r\n * Implements the \"Executing fields\" section of the spec\r\n * In particular, this function figures out the value that the field returns by\r\n * calling its resolve function, then calls completeValue to complete promises,\r\n * serialize scalars, or execute the sub-selection-set for objects.\r\n */\n\n\nfunction executeField(exeContext, parentType, source, fieldNodes, path) {\n  var _fieldDef$resolve;\n\n  const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);\n\n  if (!fieldDef) {\n    return;\n  }\n\n  const returnType = fieldDef.type;\n  const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;\n  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path); // Get the resolve function, regardless of if its result is normal or abrupt (error).\n\n  try {\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    // TODO: find a way to memoize, in case this field is within a List type.\n    const args = getArgumentValues(fieldDef, fieldNodes[0], exeContext.variableValues); // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n\n    const contextValue = exeContext.contextValue;\n    const result = resolveFn(source, args, contextValue, info);\n    let completed;\n\n    if (isPromise(result)) {\n      completed = result.then(resolved => completeValue(exeContext, returnType, fieldNodes, info, path, resolved));\n    } else {\n      completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);\n    }\n\n    if (isPromise(completed)) {\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return completed.then(undefined, rawError => {\n        const error = locatedError(rawError, fieldNodes, pathToArray(path));\n        return handleFieldError(error, returnType, exeContext);\n      });\n    }\n\n    return completed;\n  } catch (rawError) {\n    const error = locatedError(rawError, fieldNodes, pathToArray(path));\n    return handleFieldError(error, returnType, exeContext);\n  }\n}\n/**\r\n * @internal\r\n */\n\n\nexport function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {\n  // The resolve function's optional fourth argument is a collection of\n  // information about the current execution state.\n  return {\n    fieldName: fieldDef.name,\n    fieldNodes,\n    returnType: fieldDef.type,\n    parentType,\n    path,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues\n  };\n}\n\nfunction handleFieldError(error, returnType, exeContext) {\n  // If the field type is non-nullable, then it is resolved without any\n  // protection from errors, however it still properly locates the error.\n  if (isNonNullType(returnType)) {\n    throw error;\n  } // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n\n\n  exeContext.errors.push(error);\n  return null;\n}\n/**\r\n * Implements the instructions for completeValue as defined in the\r\n * \"Value Completion\" section of the spec.\r\n *\r\n * If the field type is Non-Null, then this recursively completes the value\r\n * for the inner type. It throws a field error if that completion returns null,\r\n * as per the \"Nullability\" section of the spec.\r\n *\r\n * If the field type is a List, then this recursively completes the value\r\n * for the inner type on each item in the list.\r\n *\r\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\r\n * value of the type by calling the `serialize` method of GraphQL type\r\n * definition.\r\n *\r\n * If the field is an abstract type, determine the runtime type of the value\r\n * and then complete based on that type\r\n *\r\n * Otherwise, the field type expects a sub-selection set, and will complete the\r\n * value by executing all sub-selections.\r\n */\n\n\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw result;\n  } // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n\n\n  if (isNonNullType(returnType)) {\n    const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);\n\n    if (completed === null) {\n      throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);\n    }\n\n    return completed;\n  } // If result value is null or undefined then return null.\n\n\n  if (result == null) {\n    return null;\n  } // If field type is List, complete each item in the list with the inner type\n\n\n  if (isListType(returnType)) {\n    return completeListValue(exeContext, returnType, fieldNodes, info, path, result);\n  } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n  // returning null if serialization is not possible.\n\n\n  if (isLeafType(returnType)) {\n    return completeLeafValue(returnType, result);\n  } // If field type is an abstract type, Interface or Union, determine the\n  // runtime Object type and complete for that type.\n\n\n  if (isAbstractType(returnType)) {\n    return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);\n  } // If field type is Object, execute and complete all sub-selections.\n\n\n  if (isObjectType(returnType)) {\n    return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);\n  }\n  /* c8 ignore next 6 */\n  // Not reachable, all possible output types have been considered.\n\n\n  false || invariant(false, 'Cannot complete value of unexpected output type: ' + inspect(returnType));\n}\n/**\r\n * Complete a list value by completing each item in the list with the\r\n * inner type\r\n */\n\n\nfunction completeListValue(exeContext, returnType, fieldNodes, info, path, result) {\n  if (!isIterableObject(result)) {\n    throw new GraphQLError(`Expected Iterable, but did not find one for field \"${info.parentType.name}.${info.fieldName}\".`);\n  } // This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n\n\n  const itemType = returnType.ofType;\n  let containsPromise = false;\n  const completedResults = Array.from(result, (item, index) => {\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    const itemPath = addPath(path, index, undefined);\n\n    try {\n      let completedItem;\n\n      if (isPromise(item)) {\n        completedItem = item.then(resolved => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved));\n      } else {\n        completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item);\n      }\n\n      if (isPromise(completedItem)) {\n        containsPromise = true; // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n        // to take a second callback for the error case.\n\n        return completedItem.then(undefined, rawError => {\n          const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n          return handleFieldError(error, itemType, exeContext);\n        });\n      }\n\n      return completedItem;\n    } catch (rawError) {\n      const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\n      return handleFieldError(error, itemType, exeContext);\n    }\n  });\n  return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n/**\r\n * Complete a Scalar or Enum by serializing to a valid value, returning\r\n * null if serialization is not possible.\r\n */\n\n\nfunction completeLeafValue(returnType, result) {\n  const serializedResult = returnType.serialize(result);\n\n  if (serializedResult == null) {\n    throw new Error(`Expected \\`${inspect(returnType)}.serialize(${inspect(result)})\\` to ` + `return non-nullable value, returned: ${inspect(serializedResult)}`);\n  }\n\n  return serializedResult;\n}\n/**\r\n * Complete a value of an abstract type by determining the runtime object type\r\n * of that value, then complete the value for that type.\r\n */\n\n\nfunction completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {\n  var _returnType$resolveTy;\n\n  const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;\n  const contextValue = exeContext.contextValue;\n  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n\n  if (isPromise(runtimeType)) {\n    return runtimeType.then(resolvedRuntimeType => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result));\n  }\n\n  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);\n}\n\nfunction ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {\n  if (runtimeTypeName == null) {\n    throw new GraphQLError(`Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\". Either the \"${returnType.name}\" type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function.`, fieldNodes);\n  } // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`\n  // TODO: remove in 17.0.0 release\n\n\n  if (isObjectType(runtimeTypeName)) {\n    throw new GraphQLError('Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.');\n  }\n\n  if (typeof runtimeTypeName !== 'string') {\n    throw new GraphQLError(`Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\" with ` + `value ${inspect(result)}, received \"${inspect(runtimeTypeName)}\".`);\n  }\n\n  const runtimeType = exeContext.schema.getType(runtimeTypeName);\n\n  if (runtimeType == null) {\n    throw new GraphQLError(`Abstract type \"${returnType.name}\" was resolved to a type \"${runtimeTypeName}\" that does not exist inside the schema.`, {\n      nodes: fieldNodes\n    });\n  }\n\n  if (!isObjectType(runtimeType)) {\n    throw new GraphQLError(`Abstract type \"${returnType.name}\" was resolved to a non-object type \"${runtimeTypeName}\".`, {\n      nodes: fieldNodes\n    });\n  }\n\n  if (!exeContext.schema.isSubType(returnType, runtimeType)) {\n    throw new GraphQLError(`Runtime Object type \"${runtimeType.name}\" is not a possible type for \"${returnType.name}\".`, {\n      nodes: fieldNodes\n    });\n  }\n\n  return runtimeType;\n}\n/**\r\n * Complete an Object value by executing all sub-selections.\r\n */\n\n\nfunction completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {\n  // Collect sub-fields to execute to complete this value.\n  const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes); // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n\n  if (returnType.isTypeOf) {\n    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\n\n    if (isPromise(isTypeOf)) {\n      return isTypeOf.then(resolvedIsTypeOf => {\n        if (!resolvedIsTypeOf) {\n          throw invalidReturnTypeError(returnType, result, fieldNodes);\n        }\n\n        return executeFields(exeContext, returnType, result, path, subFieldNodes);\n      });\n    }\n\n    if (!isTypeOf) {\n      throw invalidReturnTypeError(returnType, result, fieldNodes);\n    }\n  }\n\n  return executeFields(exeContext, returnType, result, path, subFieldNodes);\n}\n\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\n  return new GraphQLError(`Expected value of type \"${returnType.name}\" but got: ${inspect(result)}.`, {\n    nodes: fieldNodes\n  });\n}\n/**\r\n * If a resolveType function is not given, then a default resolve behavior is\r\n * used which attempts two strategies:\r\n *\r\n * First, See if the provided value has a `__typename` field defined, if so, use\r\n * that value as name of the resolved type.\r\n *\r\n * Otherwise, test each possible type for the abstract type by calling\r\n * isTypeOf for the object being coerced, returning the first type that matches.\r\n */\n\n\nexport const defaultTypeResolver = function (value, contextValue, info, abstractType) {\n  // First, look for `__typename`.\n  if (isObjectLike(value) && typeof value.__typename === 'string') {\n    return value.__typename;\n  } // Otherwise, test each possible type.\n\n\n  const possibleTypes = info.schema.getPossibleTypes(abstractType);\n  const promisedIsTypeOfResults = [];\n\n  for (let i = 0; i < possibleTypes.length; i++) {\n    const type = possibleTypes[i];\n\n    if (type.isTypeOf) {\n      const isTypeOfResult = type.isTypeOf(value, contextValue, info);\n\n      if (isPromise(isTypeOfResult)) {\n        promisedIsTypeOfResults[i] = isTypeOfResult;\n      } else if (isTypeOfResult) {\n        return type.name;\n      }\n    }\n  }\n\n  if (promisedIsTypeOfResults.length) {\n    return Promise.all(promisedIsTypeOfResults).then(isTypeOfResults => {\n      for (let i = 0; i < isTypeOfResults.length; i++) {\n        if (isTypeOfResults[i]) {\n          return possibleTypes[i].name;\n        }\n      }\n    });\n  }\n};\n/**\r\n * If a resolve function is not given, then a default resolve behavior is used\r\n * which takes the property of the source object of the same name as the field\r\n * and returns it as the result, or if it's a function, returns the result\r\n * of calling that function while passing along args and context value.\r\n */\n\nexport const defaultFieldResolver = function (source, args, contextValue, info) {\n  // ensure source is a value for which property access is acceptable.\n  if (isObjectLike(source) || typeof source === 'function') {\n    const property = source[info.fieldName];\n\n    if (typeof property === 'function') {\n      return source[info.fieldName](args, contextValue, info);\n    }\n\n    return property;\n  }\n};\n/**\r\n * This method looks up the field on the given type definition.\r\n * It has special casing for the three introspection fields,\r\n * __schema, __type and __typename. __typename is special because\r\n * it can always be queried as a field, even in situations where no\r\n * other fields are allowed, like on a Union. __schema and __type\r\n * could get automatically added to the query type, but that would\r\n * require mutating type definitions, which would cause issues.\r\n *\r\n * @internal\r\n */\n\nexport function getFieldDef(schema, parentType, fieldNode) {\n  const fieldName = fieldNode.name.value;\n\n  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  } else if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  } else if (fieldName === TypeNameMetaFieldDef.name) {\n    return TypeNameMetaFieldDef;\n  }\n\n  return parentType.getFields()[fieldName];\n}","map":{"version":3,"names":["devAssert","inspect","invariant","isIterableObject","isObjectLike","isPromise","memoize3","addPath","pathToArray","promiseForObject","promiseReduce","GraphQLError","locatedError","OperationTypeNode","Kind","isAbstractType","isLeafType","isListType","isNonNullType","isObjectType","SchemaMetaFieldDef","TypeMetaFieldDef","TypeNameMetaFieldDef","assertValidSchema","collectFields","collectSubfields","_collectSubfields","getArgumentValues","getVariableValues","exeContext","returnType","fieldNodes","schema","fragments","variableValues","execute","args","arguments","length","document","rootValue","assertValidExecutionArguments","buildExecutionContext","errors","operation","result","executeOperation","then","data","buildResponse","error","push","executeSync","Error","rawVariableValues","_definition$name","_operation$variableDe","contextValue","operationName","fieldResolver","typeResolver","subscribeFieldResolver","Object","create","definition","definitions","kind","OPERATION_DEFINITION","undefined","name","value","FRAGMENT_DEFINITION","variableDefinitions","coercedVariableValues","maxErrors","coerced","defaultFieldResolver","defaultTypeResolver","rootType","getRootType","nodes","rootFields","selectionSet","path","QUERY","executeFields","MUTATION","executeFieldsSerially","SUBSCRIPTION","parentType","sourceValue","fields","entries","results","responseName","fieldPath","executeField","resolvedResult","containsPromise","source","_fieldDef$resolve","fieldDef","getFieldDef","type","resolveFn","resolve","info","buildResolveInfo","completed","resolved","completeValue","rawError","handleFieldError","fieldName","ofType","completeListValue","completeLeafValue","completeAbstractValue","completeObjectValue","itemType","completedResults","Array","from","item","index","itemPath","completedItem","Promise","all","serializedResult","serialize","_returnType$resolveTy","resolveTypeFn","resolveType","runtimeType","resolvedRuntimeType","ensureValidRuntimeType","runtimeTypeName","getType","isSubType","subFieldNodes","isTypeOf","resolvedIsTypeOf","invalidReturnTypeError","abstractType","__typename","possibleTypes","getPossibleTypes","promisedIsTypeOfResults","i","isTypeOfResult","isTypeOfResults","property","fieldNode","getQueryType","getFields"],"sources":["C:/Users/Dani/Desktop/projects/dream-small/dream-small/node_modules/graphql/execution/execute.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\r\nimport { inspect } from '../jsutils/inspect.mjs';\r\nimport { invariant } from '../jsutils/invariant.mjs';\r\nimport { isIterableObject } from '../jsutils/isIterableObject.mjs';\r\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\r\nimport { isPromise } from '../jsutils/isPromise.mjs';\r\nimport { memoize3 } from '../jsutils/memoize3.mjs';\r\nimport { addPath, pathToArray } from '../jsutils/Path.mjs';\r\nimport { promiseForObject } from '../jsutils/promiseForObject.mjs';\r\nimport { promiseReduce } from '../jsutils/promiseReduce.mjs';\r\nimport { GraphQLError } from '../error/GraphQLError.mjs';\r\nimport { locatedError } from '../error/locatedError.mjs';\r\nimport { OperationTypeNode } from '../language/ast.mjs';\r\nimport { Kind } from '../language/kinds.mjs';\r\nimport {\r\n  isAbstractType,\r\n  isLeafType,\r\n  isListType,\r\n  isNonNullType,\r\n  isObjectType,\r\n} from '../type/definition.mjs';\r\nimport {\r\n  SchemaMetaFieldDef,\r\n  TypeMetaFieldDef,\r\n  TypeNameMetaFieldDef,\r\n} from '../type/introspection.mjs';\r\nimport { assertValidSchema } from '../type/validate.mjs';\r\nimport {\r\n  collectFields,\r\n  collectSubfields as _collectSubfields,\r\n} from './collectFields.mjs';\r\nimport { getArgumentValues, getVariableValues } from './values.mjs';\r\n/**\r\n * A memoized collection of relevant subfields with regard to the return\r\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\r\n * saves overhead when resolving lists of values.\r\n */\r\n\r\nconst collectSubfields = memoize3((exeContext, returnType, fieldNodes) =>\r\n  _collectSubfields(\r\n    exeContext.schema,\r\n    exeContext.fragments,\r\n    exeContext.variableValues,\r\n    returnType,\r\n    fieldNodes,\r\n  ),\r\n);\r\n/**\r\n * Terminology\r\n *\r\n * \"Definitions\" are the generic name for top-level statements in the document.\r\n * Examples of this include:\r\n * 1) Operations (such as a query)\r\n * 2) Fragments\r\n *\r\n * \"Operations\" are a generic name for requests in the document.\r\n * Examples of this include:\r\n * 1) query,\r\n * 2) mutation\r\n *\r\n * \"Selections\" are the definitions that can appear legally and at\r\n * single level of the query. These include:\r\n * 1) field references e.g `a`\r\n * 2) fragment \"spreads\" e.g. `...c`\r\n * 3) inline fragment \"spreads\" e.g. `...on Type { a }`\r\n */\r\n\r\n/**\r\n * Data that must be available at all points during query execution.\r\n *\r\n * Namely, schema of the type system that is currently executing,\r\n * and the fragments defined in the query document\r\n */\r\n\r\n/**\r\n * Implements the \"Executing requests\" section of the GraphQL specification.\r\n *\r\n * Returns either a synchronous ExecutionResult (if all encountered resolvers\r\n * are synchronous), or a Promise of an ExecutionResult that will eventually be\r\n * resolved and never rejected.\r\n *\r\n * If the arguments to this function do not result in a legal execution context,\r\n * a GraphQLError will be thrown immediately explaining the invalid input.\r\n */\r\nexport function execute(args) {\r\n  // Temporary for v15 to v16 migration. Remove in v17\r\n  arguments.length < 2 ||\r\n    devAssert(\r\n      false,\r\n      'graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.',\r\n    );\r\n  const { schema, document, variableValues, rootValue } = args; // If arguments are missing or incorrect, throw an error.\r\n\r\n  assertValidExecutionArguments(schema, document, variableValues); // If a valid execution context cannot be created due to incorrect arguments,\r\n  // a \"Response\" with only errors is returned.\r\n\r\n  const exeContext = buildExecutionContext(args); // Return early errors if execution context failed.\r\n\r\n  if (!('schema' in exeContext)) {\r\n    return {\r\n      errors: exeContext,\r\n    };\r\n  } // Return a Promise that will eventually resolve to the data described by\r\n  // The \"Response\" section of the GraphQL specification.\r\n  //\r\n  // If errors are encountered while executing a GraphQL field, only that\r\n  // field and its descendants will be omitted, and sibling fields will still\r\n  // be executed. An execution which encounters errors will still result in a\r\n  // resolved Promise.\r\n  //\r\n  // Errors from sub-fields of a NonNull type may propagate to the top level,\r\n  // at which point we still log the error and null the parent field, which\r\n  // in this case is the entire response.\r\n\r\n  try {\r\n    const { operation } = exeContext;\r\n    const result = executeOperation(exeContext, operation, rootValue);\r\n\r\n    if (isPromise(result)) {\r\n      return result.then(\r\n        (data) => buildResponse(data, exeContext.errors),\r\n        (error) => {\r\n          exeContext.errors.push(error);\r\n          return buildResponse(null, exeContext.errors);\r\n        },\r\n      );\r\n    }\r\n\r\n    return buildResponse(result, exeContext.errors);\r\n  } catch (error) {\r\n    exeContext.errors.push(error);\r\n    return buildResponse(null, exeContext.errors);\r\n  }\r\n}\r\n/**\r\n * Also implements the \"Executing requests\" section of the GraphQL specification.\r\n * However, it guarantees to complete synchronously (or throw an error) assuming\r\n * that all field resolvers are also synchronous.\r\n */\r\n\r\nexport function executeSync(args) {\r\n  const result = execute(args); // Assert that the execution was synchronous.\r\n\r\n  if (isPromise(result)) {\r\n    throw new Error('GraphQL execution failed to complete synchronously.');\r\n  }\r\n\r\n  return result;\r\n}\r\n/**\r\n * Given a completed execution context and data, build the `{ errors, data }`\r\n * response defined by the \"Response\" section of the GraphQL specification.\r\n */\r\n\r\nfunction buildResponse(data, errors) {\r\n  return errors.length === 0\r\n    ? {\r\n        data,\r\n      }\r\n    : {\r\n        errors,\r\n        data,\r\n      };\r\n}\r\n/**\r\n * Essential assertions before executing to provide developer feedback for\r\n * improper use of the GraphQL library.\r\n *\r\n * @internal\r\n */\r\n\r\nexport function assertValidExecutionArguments(\r\n  schema,\r\n  document,\r\n  rawVariableValues,\r\n) {\r\n  document || devAssert(false, 'Must provide document.'); // If the schema used for execution is invalid, throw an error.\r\n\r\n  assertValidSchema(schema); // Variables, if provided, must be an object.\r\n\r\n  rawVariableValues == null ||\r\n    isObjectLike(rawVariableValues) ||\r\n    devAssert(\r\n      false,\r\n      'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.',\r\n    );\r\n}\r\n/**\r\n * Constructs a ExecutionContext object from the arguments passed to\r\n * execute, which we will pass throughout the other execution methods.\r\n *\r\n * Throws a GraphQLError if a valid execution context cannot be created.\r\n *\r\n * @internal\r\n */\r\n\r\nexport function buildExecutionContext(args) {\r\n  var _definition$name, _operation$variableDe;\r\n\r\n  const {\r\n    schema,\r\n    document,\r\n    rootValue,\r\n    contextValue,\r\n    variableValues: rawVariableValues,\r\n    operationName,\r\n    fieldResolver,\r\n    typeResolver,\r\n    subscribeFieldResolver,\r\n  } = args;\r\n  let operation;\r\n  const fragments = Object.create(null);\r\n\r\n  for (const definition of document.definitions) {\r\n    switch (definition.kind) {\r\n      case Kind.OPERATION_DEFINITION:\r\n        if (operationName == null) {\r\n          if (operation !== undefined) {\r\n            return [\r\n              new GraphQLError(\r\n                'Must provide operation name if query contains multiple operations.',\r\n              ),\r\n            ];\r\n          }\r\n\r\n          operation = definition;\r\n        } else if (\r\n          ((_definition$name = definition.name) === null ||\r\n          _definition$name === void 0\r\n            ? void 0\r\n            : _definition$name.value) === operationName\r\n        ) {\r\n          operation = definition;\r\n        }\r\n\r\n        break;\r\n\r\n      case Kind.FRAGMENT_DEFINITION:\r\n        fragments[definition.name.value] = definition;\r\n        break;\r\n\r\n      default: // ignore non-executable definitions\r\n    }\r\n  }\r\n\r\n  if (!operation) {\r\n    if (operationName != null) {\r\n      return [new GraphQLError(`Unknown operation named \"${operationName}\".`)];\r\n    }\r\n\r\n    return [new GraphQLError('Must provide an operation.')];\r\n  } // FIXME: https://github.com/graphql/graphql-js/issues/2203\r\n\r\n  /* c8 ignore next */\r\n\r\n  const variableDefinitions =\r\n    (_operation$variableDe = operation.variableDefinitions) !== null &&\r\n    _operation$variableDe !== void 0\r\n      ? _operation$variableDe\r\n      : [];\r\n  const coercedVariableValues = getVariableValues(\r\n    schema,\r\n    variableDefinitions,\r\n    rawVariableValues !== null && rawVariableValues !== void 0\r\n      ? rawVariableValues\r\n      : {},\r\n    {\r\n      maxErrors: 50,\r\n    },\r\n  );\r\n\r\n  if (coercedVariableValues.errors) {\r\n    return coercedVariableValues.errors;\r\n  }\r\n\r\n  return {\r\n    schema,\r\n    fragments,\r\n    rootValue,\r\n    contextValue,\r\n    operation,\r\n    variableValues: coercedVariableValues.coerced,\r\n    fieldResolver:\r\n      fieldResolver !== null && fieldResolver !== void 0\r\n        ? fieldResolver\r\n        : defaultFieldResolver,\r\n    typeResolver:\r\n      typeResolver !== null && typeResolver !== void 0\r\n        ? typeResolver\r\n        : defaultTypeResolver,\r\n    subscribeFieldResolver:\r\n      subscribeFieldResolver !== null && subscribeFieldResolver !== void 0\r\n        ? subscribeFieldResolver\r\n        : defaultFieldResolver,\r\n    errors: [],\r\n  };\r\n}\r\n/**\r\n * Implements the \"Executing operations\" section of the spec.\r\n */\r\n\r\nfunction executeOperation(exeContext, operation, rootValue) {\r\n  const rootType = exeContext.schema.getRootType(operation.operation);\r\n\r\n  if (rootType == null) {\r\n    throw new GraphQLError(\r\n      `Schema is not configured to execute ${operation.operation} operation.`,\r\n      {\r\n        nodes: operation,\r\n      },\r\n    );\r\n  }\r\n\r\n  const rootFields = collectFields(\r\n    exeContext.schema,\r\n    exeContext.fragments,\r\n    exeContext.variableValues,\r\n    rootType,\r\n    operation.selectionSet,\r\n  );\r\n  const path = undefined;\r\n\r\n  switch (operation.operation) {\r\n    case OperationTypeNode.QUERY:\r\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\r\n\r\n    case OperationTypeNode.MUTATION:\r\n      return executeFieldsSerially(\r\n        exeContext,\r\n        rootType,\r\n        rootValue,\r\n        path,\r\n        rootFields,\r\n      );\r\n\r\n    case OperationTypeNode.SUBSCRIPTION:\r\n      // TODO: deprecate `subscribe` and move all logic here\r\n      // Temporary solution until we finish merging execute and subscribe together\r\n      return executeFields(exeContext, rootType, rootValue, path, rootFields);\r\n  }\r\n}\r\n/**\r\n * Implements the \"Executing selection sets\" section of the spec\r\n * for fields that must be executed serially.\r\n */\r\n\r\nfunction executeFieldsSerially(\r\n  exeContext,\r\n  parentType,\r\n  sourceValue,\r\n  path,\r\n  fields,\r\n) {\r\n  return promiseReduce(\r\n    fields.entries(),\r\n    (results, [responseName, fieldNodes]) => {\r\n      const fieldPath = addPath(path, responseName, parentType.name);\r\n      const result = executeField(\r\n        exeContext,\r\n        parentType,\r\n        sourceValue,\r\n        fieldNodes,\r\n        fieldPath,\r\n      );\r\n\r\n      if (result === undefined) {\r\n        return results;\r\n      }\r\n\r\n      if (isPromise(result)) {\r\n        return result.then((resolvedResult) => {\r\n          results[responseName] = resolvedResult;\r\n          return results;\r\n        });\r\n      }\r\n\r\n      results[responseName] = result;\r\n      return results;\r\n    },\r\n    Object.create(null),\r\n  );\r\n}\r\n/**\r\n * Implements the \"Executing selection sets\" section of the spec\r\n * for fields that may be executed in parallel.\r\n */\r\n\r\nfunction executeFields(exeContext, parentType, sourceValue, path, fields) {\r\n  const results = Object.create(null);\r\n  let containsPromise = false;\r\n\r\n  for (const [responseName, fieldNodes] of fields.entries()) {\r\n    const fieldPath = addPath(path, responseName, parentType.name);\r\n    const result = executeField(\r\n      exeContext,\r\n      parentType,\r\n      sourceValue,\r\n      fieldNodes,\r\n      fieldPath,\r\n    );\r\n\r\n    if (result !== undefined) {\r\n      results[responseName] = result;\r\n\r\n      if (isPromise(result)) {\r\n        containsPromise = true;\r\n      }\r\n    }\r\n  } // If there are no promises, we can just return the object\r\n\r\n  if (!containsPromise) {\r\n    return results;\r\n  } // Otherwise, results is a map from field name to the result of resolving that\r\n  // field, which is possibly a promise. Return a promise that will return this\r\n  // same map, but with any promises replaced with the values they resolved to.\r\n\r\n  return promiseForObject(results);\r\n}\r\n/**\r\n * Implements the \"Executing fields\" section of the spec\r\n * In particular, this function figures out the value that the field returns by\r\n * calling its resolve function, then calls completeValue to complete promises,\r\n * serialize scalars, or execute the sub-selection-set for objects.\r\n */\r\n\r\nfunction executeField(exeContext, parentType, source, fieldNodes, path) {\r\n  var _fieldDef$resolve;\r\n\r\n  const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);\r\n\r\n  if (!fieldDef) {\r\n    return;\r\n  }\r\n\r\n  const returnType = fieldDef.type;\r\n  const resolveFn =\r\n    (_fieldDef$resolve = fieldDef.resolve) !== null &&\r\n    _fieldDef$resolve !== void 0\r\n      ? _fieldDef$resolve\r\n      : exeContext.fieldResolver;\r\n  const info = buildResolveInfo(\r\n    exeContext,\r\n    fieldDef,\r\n    fieldNodes,\r\n    parentType,\r\n    path,\r\n  ); // Get the resolve function, regardless of if its result is normal or abrupt (error).\r\n\r\n  try {\r\n    // Build a JS object of arguments from the field.arguments AST, using the\r\n    // variables scope to fulfill any variable references.\r\n    // TODO: find a way to memoize, in case this field is within a List type.\r\n    const args = getArgumentValues(\r\n      fieldDef,\r\n      fieldNodes[0],\r\n      exeContext.variableValues,\r\n    ); // The resolve function's optional third argument is a context value that\r\n    // is provided to every resolve function within an execution. It is commonly\r\n    // used to represent an authenticated user, or request-specific caches.\r\n\r\n    const contextValue = exeContext.contextValue;\r\n    const result = resolveFn(source, args, contextValue, info);\r\n    let completed;\r\n\r\n    if (isPromise(result)) {\r\n      completed = result.then((resolved) =>\r\n        completeValue(exeContext, returnType, fieldNodes, info, path, resolved),\r\n      );\r\n    } else {\r\n      completed = completeValue(\r\n        exeContext,\r\n        returnType,\r\n        fieldNodes,\r\n        info,\r\n        path,\r\n        result,\r\n      );\r\n    }\r\n\r\n    if (isPromise(completed)) {\r\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\r\n      // to take a second callback for the error case.\r\n      return completed.then(undefined, (rawError) => {\r\n        const error = locatedError(rawError, fieldNodes, pathToArray(path));\r\n        return handleFieldError(error, returnType, exeContext);\r\n      });\r\n    }\r\n\r\n    return completed;\r\n  } catch (rawError) {\r\n    const error = locatedError(rawError, fieldNodes, pathToArray(path));\r\n    return handleFieldError(error, returnType, exeContext);\r\n  }\r\n}\r\n/**\r\n * @internal\r\n */\r\n\r\nexport function buildResolveInfo(\r\n  exeContext,\r\n  fieldDef,\r\n  fieldNodes,\r\n  parentType,\r\n  path,\r\n) {\r\n  // The resolve function's optional fourth argument is a collection of\r\n  // information about the current execution state.\r\n  return {\r\n    fieldName: fieldDef.name,\r\n    fieldNodes,\r\n    returnType: fieldDef.type,\r\n    parentType,\r\n    path,\r\n    schema: exeContext.schema,\r\n    fragments: exeContext.fragments,\r\n    rootValue: exeContext.rootValue,\r\n    operation: exeContext.operation,\r\n    variableValues: exeContext.variableValues,\r\n  };\r\n}\r\n\r\nfunction handleFieldError(error, returnType, exeContext) {\r\n  // If the field type is non-nullable, then it is resolved without any\r\n  // protection from errors, however it still properly locates the error.\r\n  if (isNonNullType(returnType)) {\r\n    throw error;\r\n  } // Otherwise, error protection is applied, logging the error and resolving\r\n  // a null value for this field if one is encountered.\r\n\r\n  exeContext.errors.push(error);\r\n  return null;\r\n}\r\n/**\r\n * Implements the instructions for completeValue as defined in the\r\n * \"Value Completion\" section of the spec.\r\n *\r\n * If the field type is Non-Null, then this recursively completes the value\r\n * for the inner type. It throws a field error if that completion returns null,\r\n * as per the \"Nullability\" section of the spec.\r\n *\r\n * If the field type is a List, then this recursively completes the value\r\n * for the inner type on each item in the list.\r\n *\r\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\r\n * value of the type by calling the `serialize` method of GraphQL type\r\n * definition.\r\n *\r\n * If the field is an abstract type, determine the runtime type of the value\r\n * and then complete based on that type\r\n *\r\n * Otherwise, the field type expects a sub-selection set, and will complete the\r\n * value by executing all sub-selections.\r\n */\r\n\r\nfunction completeValue(exeContext, returnType, fieldNodes, info, path, result) {\r\n  // If result is an Error, throw a located error.\r\n  if (result instanceof Error) {\r\n    throw result;\r\n  } // If field type is NonNull, complete for inner type, and throw field error\r\n  // if result is null.\r\n\r\n  if (isNonNullType(returnType)) {\r\n    const completed = completeValue(\r\n      exeContext,\r\n      returnType.ofType,\r\n      fieldNodes,\r\n      info,\r\n      path,\r\n      result,\r\n    );\r\n\r\n    if (completed === null) {\r\n      throw new Error(\r\n        `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`,\r\n      );\r\n    }\r\n\r\n    return completed;\r\n  } // If result value is null or undefined then return null.\r\n\r\n  if (result == null) {\r\n    return null;\r\n  } // If field type is List, complete each item in the list with the inner type\r\n\r\n  if (isListType(returnType)) {\r\n    return completeListValue(\r\n      exeContext,\r\n      returnType,\r\n      fieldNodes,\r\n      info,\r\n      path,\r\n      result,\r\n    );\r\n  } // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\r\n  // returning null if serialization is not possible.\r\n\r\n  if (isLeafType(returnType)) {\r\n    return completeLeafValue(returnType, result);\r\n  } // If field type is an abstract type, Interface or Union, determine the\r\n  // runtime Object type and complete for that type.\r\n\r\n  if (isAbstractType(returnType)) {\r\n    return completeAbstractValue(\r\n      exeContext,\r\n      returnType,\r\n      fieldNodes,\r\n      info,\r\n      path,\r\n      result,\r\n    );\r\n  } // If field type is Object, execute and complete all sub-selections.\r\n\r\n  if (isObjectType(returnType)) {\r\n    return completeObjectValue(\r\n      exeContext,\r\n      returnType,\r\n      fieldNodes,\r\n      info,\r\n      path,\r\n      result,\r\n    );\r\n  }\r\n  /* c8 ignore next 6 */\r\n  // Not reachable, all possible output types have been considered.\r\n\r\n  false ||\r\n    invariant(\r\n      false,\r\n      'Cannot complete value of unexpected output type: ' + inspect(returnType),\r\n    );\r\n}\r\n/**\r\n * Complete a list value by completing each item in the list with the\r\n * inner type\r\n */\r\n\r\nfunction completeListValue(\r\n  exeContext,\r\n  returnType,\r\n  fieldNodes,\r\n  info,\r\n  path,\r\n  result,\r\n) {\r\n  if (!isIterableObject(result)) {\r\n    throw new GraphQLError(\r\n      `Expected Iterable, but did not find one for field \"${info.parentType.name}.${info.fieldName}\".`,\r\n    );\r\n  } // This is specified as a simple map, however we're optimizing the path\r\n  // where the list contains no Promises by avoiding creating another Promise.\r\n\r\n  const itemType = returnType.ofType;\r\n  let containsPromise = false;\r\n  const completedResults = Array.from(result, (item, index) => {\r\n    // No need to modify the info object containing the path,\r\n    // since from here on it is not ever accessed by resolver functions.\r\n    const itemPath = addPath(path, index, undefined);\r\n\r\n    try {\r\n      let completedItem;\r\n\r\n      if (isPromise(item)) {\r\n        completedItem = item.then((resolved) =>\r\n          completeValue(\r\n            exeContext,\r\n            itemType,\r\n            fieldNodes,\r\n            info,\r\n            itemPath,\r\n            resolved,\r\n          ),\r\n        );\r\n      } else {\r\n        completedItem = completeValue(\r\n          exeContext,\r\n          itemType,\r\n          fieldNodes,\r\n          info,\r\n          itemPath,\r\n          item,\r\n        );\r\n      }\r\n\r\n      if (isPromise(completedItem)) {\r\n        containsPromise = true; // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\r\n        // to take a second callback for the error case.\r\n\r\n        return completedItem.then(undefined, (rawError) => {\r\n          const error = locatedError(\r\n            rawError,\r\n            fieldNodes,\r\n            pathToArray(itemPath),\r\n          );\r\n          return handleFieldError(error, itemType, exeContext);\r\n        });\r\n      }\r\n\r\n      return completedItem;\r\n    } catch (rawError) {\r\n      const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));\r\n      return handleFieldError(error, itemType, exeContext);\r\n    }\r\n  });\r\n  return containsPromise ? Promise.all(completedResults) : completedResults;\r\n}\r\n/**\r\n * Complete a Scalar or Enum by serializing to a valid value, returning\r\n * null if serialization is not possible.\r\n */\r\n\r\nfunction completeLeafValue(returnType, result) {\r\n  const serializedResult = returnType.serialize(result);\r\n\r\n  if (serializedResult == null) {\r\n    throw new Error(\r\n      `Expected \\`${inspect(returnType)}.serialize(${inspect(result)})\\` to ` +\r\n        `return non-nullable value, returned: ${inspect(serializedResult)}`,\r\n    );\r\n  }\r\n\r\n  return serializedResult;\r\n}\r\n/**\r\n * Complete a value of an abstract type by determining the runtime object type\r\n * of that value, then complete the value for that type.\r\n */\r\n\r\nfunction completeAbstractValue(\r\n  exeContext,\r\n  returnType,\r\n  fieldNodes,\r\n  info,\r\n  path,\r\n  result,\r\n) {\r\n  var _returnType$resolveTy;\r\n\r\n  const resolveTypeFn =\r\n    (_returnType$resolveTy = returnType.resolveType) !== null &&\r\n    _returnType$resolveTy !== void 0\r\n      ? _returnType$resolveTy\r\n      : exeContext.typeResolver;\r\n  const contextValue = exeContext.contextValue;\r\n  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);\r\n\r\n  if (isPromise(runtimeType)) {\r\n    return runtimeType.then((resolvedRuntimeType) =>\r\n      completeObjectValue(\r\n        exeContext,\r\n        ensureValidRuntimeType(\r\n          resolvedRuntimeType,\r\n          exeContext,\r\n          returnType,\r\n          fieldNodes,\r\n          info,\r\n          result,\r\n        ),\r\n        fieldNodes,\r\n        info,\r\n        path,\r\n        result,\r\n      ),\r\n    );\r\n  }\r\n\r\n  return completeObjectValue(\r\n    exeContext,\r\n    ensureValidRuntimeType(\r\n      runtimeType,\r\n      exeContext,\r\n      returnType,\r\n      fieldNodes,\r\n      info,\r\n      result,\r\n    ),\r\n    fieldNodes,\r\n    info,\r\n    path,\r\n    result,\r\n  );\r\n}\r\n\r\nfunction ensureValidRuntimeType(\r\n  runtimeTypeName,\r\n  exeContext,\r\n  returnType,\r\n  fieldNodes,\r\n  info,\r\n  result,\r\n) {\r\n  if (runtimeTypeName == null) {\r\n    throw new GraphQLError(\r\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\". Either the \"${returnType.name}\" type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function.`,\r\n      fieldNodes,\r\n    );\r\n  } // releases before 16.0.0 supported returning `GraphQLObjectType` from `resolveType`\r\n  // TODO: remove in 17.0.0 release\r\n\r\n  if (isObjectType(runtimeTypeName)) {\r\n    throw new GraphQLError(\r\n      'Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.',\r\n    );\r\n  }\r\n\r\n  if (typeof runtimeTypeName !== 'string') {\r\n    throw new GraphQLError(\r\n      `Abstract type \"${returnType.name}\" must resolve to an Object type at runtime for field \"${info.parentType.name}.${info.fieldName}\" with ` +\r\n        `value ${inspect(result)}, received \"${inspect(runtimeTypeName)}\".`,\r\n    );\r\n  }\r\n\r\n  const runtimeType = exeContext.schema.getType(runtimeTypeName);\r\n\r\n  if (runtimeType == null) {\r\n    throw new GraphQLError(\r\n      `Abstract type \"${returnType.name}\" was resolved to a type \"${runtimeTypeName}\" that does not exist inside the schema.`,\r\n      {\r\n        nodes: fieldNodes,\r\n      },\r\n    );\r\n  }\r\n\r\n  if (!isObjectType(runtimeType)) {\r\n    throw new GraphQLError(\r\n      `Abstract type \"${returnType.name}\" was resolved to a non-object type \"${runtimeTypeName}\".`,\r\n      {\r\n        nodes: fieldNodes,\r\n      },\r\n    );\r\n  }\r\n\r\n  if (!exeContext.schema.isSubType(returnType, runtimeType)) {\r\n    throw new GraphQLError(\r\n      `Runtime Object type \"${runtimeType.name}\" is not a possible type for \"${returnType.name}\".`,\r\n      {\r\n        nodes: fieldNodes,\r\n      },\r\n    );\r\n  }\r\n\r\n  return runtimeType;\r\n}\r\n/**\r\n * Complete an Object value by executing all sub-selections.\r\n */\r\n\r\nfunction completeObjectValue(\r\n  exeContext,\r\n  returnType,\r\n  fieldNodes,\r\n  info,\r\n  path,\r\n  result,\r\n) {\r\n  // Collect sub-fields to execute to complete this value.\r\n  const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes); // If there is an isTypeOf predicate function, call it with the\r\n  // current result. If isTypeOf returns false, then raise an error rather\r\n  // than continuing execution.\r\n\r\n  if (returnType.isTypeOf) {\r\n    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);\r\n\r\n    if (isPromise(isTypeOf)) {\r\n      return isTypeOf.then((resolvedIsTypeOf) => {\r\n        if (!resolvedIsTypeOf) {\r\n          throw invalidReturnTypeError(returnType, result, fieldNodes);\r\n        }\r\n\r\n        return executeFields(\r\n          exeContext,\r\n          returnType,\r\n          result,\r\n          path,\r\n          subFieldNodes,\r\n        );\r\n      });\r\n    }\r\n\r\n    if (!isTypeOf) {\r\n      throw invalidReturnTypeError(returnType, result, fieldNodes);\r\n    }\r\n  }\r\n\r\n  return executeFields(exeContext, returnType, result, path, subFieldNodes);\r\n}\r\n\r\nfunction invalidReturnTypeError(returnType, result, fieldNodes) {\r\n  return new GraphQLError(\r\n    `Expected value of type \"${returnType.name}\" but got: ${inspect(result)}.`,\r\n    {\r\n      nodes: fieldNodes,\r\n    },\r\n  );\r\n}\r\n/**\r\n * If a resolveType function is not given, then a default resolve behavior is\r\n * used which attempts two strategies:\r\n *\r\n * First, See if the provided value has a `__typename` field defined, if so, use\r\n * that value as name of the resolved type.\r\n *\r\n * Otherwise, test each possible type for the abstract type by calling\r\n * isTypeOf for the object being coerced, returning the first type that matches.\r\n */\r\n\r\nexport const defaultTypeResolver = function (\r\n  value,\r\n  contextValue,\r\n  info,\r\n  abstractType,\r\n) {\r\n  // First, look for `__typename`.\r\n  if (isObjectLike(value) && typeof value.__typename === 'string') {\r\n    return value.__typename;\r\n  } // Otherwise, test each possible type.\r\n\r\n  const possibleTypes = info.schema.getPossibleTypes(abstractType);\r\n  const promisedIsTypeOfResults = [];\r\n\r\n  for (let i = 0; i < possibleTypes.length; i++) {\r\n    const type = possibleTypes[i];\r\n\r\n    if (type.isTypeOf) {\r\n      const isTypeOfResult = type.isTypeOf(value, contextValue, info);\r\n\r\n      if (isPromise(isTypeOfResult)) {\r\n        promisedIsTypeOfResults[i] = isTypeOfResult;\r\n      } else if (isTypeOfResult) {\r\n        return type.name;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (promisedIsTypeOfResults.length) {\r\n    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {\r\n      for (let i = 0; i < isTypeOfResults.length; i++) {\r\n        if (isTypeOfResults[i]) {\r\n          return possibleTypes[i].name;\r\n        }\r\n      }\r\n    });\r\n  }\r\n};\r\n/**\r\n * If a resolve function is not given, then a default resolve behavior is used\r\n * which takes the property of the source object of the same name as the field\r\n * and returns it as the result, or if it's a function, returns the result\r\n * of calling that function while passing along args and context value.\r\n */\r\n\r\nexport const defaultFieldResolver = function (\r\n  source,\r\n  args,\r\n  contextValue,\r\n  info,\r\n) {\r\n  // ensure source is a value for which property access is acceptable.\r\n  if (isObjectLike(source) || typeof source === 'function') {\r\n    const property = source[info.fieldName];\r\n\r\n    if (typeof property === 'function') {\r\n      return source[info.fieldName](args, contextValue, info);\r\n    }\r\n\r\n    return property;\r\n  }\r\n};\r\n/**\r\n * This method looks up the field on the given type definition.\r\n * It has special casing for the three introspection fields,\r\n * __schema, __type and __typename. __typename is special because\r\n * it can always be queried as a field, even in situations where no\r\n * other fields are allowed, like on a Union. __schema and __type\r\n * could get automatically added to the query type, but that would\r\n * require mutating type definitions, which would cause issues.\r\n *\r\n * @internal\r\n */\r\n\r\nexport function getFieldDef(schema, parentType, fieldNode) {\r\n  const fieldName = fieldNode.name.value;\r\n\r\n  if (\r\n    fieldName === SchemaMetaFieldDef.name &&\r\n    schema.getQueryType() === parentType\r\n  ) {\r\n    return SchemaMetaFieldDef;\r\n  } else if (\r\n    fieldName === TypeMetaFieldDef.name &&\r\n    schema.getQueryType() === parentType\r\n  ) {\r\n    return TypeMetaFieldDef;\r\n  } else if (fieldName === TypeNameMetaFieldDef.name) {\r\n    return TypeNameMetaFieldDef;\r\n  }\r\n\r\n  return parentType.getFields()[fieldName];\r\n}\r\n"],"mappings":"AAAA,SAASA,SAAT,QAA0B,0BAA1B;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,SAASC,SAAT,QAA0B,0BAA1B;AACA,SAASC,gBAAT,QAAiC,iCAAjC;AACA,SAASC,YAAT,QAA6B,6BAA7B;AACA,SAASC,SAAT,QAA0B,0BAA1B;AACA,SAASC,QAAT,QAAyB,yBAAzB;AACA,SAASC,OAAT,EAAkBC,WAAlB,QAAqC,qBAArC;AACA,SAASC,gBAAT,QAAiC,iCAAjC;AACA,SAASC,aAAT,QAA8B,8BAA9B;AACA,SAASC,YAAT,QAA6B,2BAA7B;AACA,SAASC,YAAT,QAA6B,2BAA7B;AACA,SAASC,iBAAT,QAAkC,qBAAlC;AACA,SAASC,IAAT,QAAqB,uBAArB;AACA,SACEC,cADF,EAEEC,UAFF,EAGEC,UAHF,EAIEC,aAJF,EAKEC,YALF,QAMO,wBANP;AAOA,SACEC,kBADF,EAEEC,gBAFF,EAGEC,oBAHF,QAIO,2BAJP;AAKA,SAASC,iBAAT,QAAkC,sBAAlC;AACA,SACEC,aADF,EAEEC,gBAAgB,IAAIC,iBAFtB,QAGO,qBAHP;AAIA,SAASC,iBAAT,EAA4BC,iBAA5B,QAAqD,cAArD;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMH,gBAAgB,GAAGnB,QAAQ,CAAC,CAACuB,UAAD,EAAaC,UAAb,EAAyBC,UAAzB,KAChCL,iBAAiB,CACfG,UAAU,CAACG,MADI,EAEfH,UAAU,CAACI,SAFI,EAGfJ,UAAU,CAACK,cAHI,EAIfJ,UAJe,EAKfC,UALe,CADc,CAAjC;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,OAAT,CAAiBC,IAAjB,EAAuB;EAC5B;EACAC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IACEtC,SAAS,CACP,KADO,EAEP,qGAFO,CADX;EAKA,MAAM;IAAEgC,MAAF;IAAUO,QAAV;IAAoBL,cAApB;IAAoCM;EAApC,IAAkDJ,IAAxD,CAP4B,CAOkC;;EAE9DK,6BAA6B,CAACT,MAAD,EAASO,QAAT,EAAmBL,cAAnB,CAA7B,CAT4B,CASqC;EACjE;;EAEA,MAAML,UAAU,GAAGa,qBAAqB,CAACN,IAAD,CAAxC,CAZ4B,CAYoB;;EAEhD,IAAI,EAAE,YAAYP,UAAd,CAAJ,EAA+B;IAC7B,OAAO;MACLc,MAAM,EAAEd;IADH,CAAP;EAGD,CAlB2B,CAkB1B;EACF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;;EAEA,IAAI;IACF,MAAM;MAAEe;IAAF,IAAgBf,UAAtB;IACA,MAAMgB,MAAM,GAAGC,gBAAgB,CAACjB,UAAD,EAAae,SAAb,EAAwBJ,SAAxB,CAA/B;;IAEA,IAAInC,SAAS,CAACwC,MAAD,CAAb,EAAuB;MACrB,OAAOA,MAAM,CAACE,IAAP,CACJC,IAAD,IAAUC,aAAa,CAACD,IAAD,EAAOnB,UAAU,CAACc,MAAlB,CADlB,EAEJO,KAAD,IAAW;QACTrB,UAAU,CAACc,MAAX,CAAkBQ,IAAlB,CAAuBD,KAAvB;QACA,OAAOD,aAAa,CAAC,IAAD,EAAOpB,UAAU,CAACc,MAAlB,CAApB;MACD,CALI,CAAP;IAOD;;IAED,OAAOM,aAAa,CAACJ,MAAD,EAAShB,UAAU,CAACc,MAApB,CAApB;EACD,CAfD,CAeE,OAAOO,KAAP,EAAc;IACdrB,UAAU,CAACc,MAAX,CAAkBQ,IAAlB,CAAuBD,KAAvB;IACA,OAAOD,aAAa,CAAC,IAAD,EAAOpB,UAAU,CAACc,MAAlB,CAApB;EACD;AACF;AACD;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASS,WAAT,CAAqBhB,IAArB,EAA2B;EAChC,MAAMS,MAAM,GAAGV,OAAO,CAACC,IAAD,CAAtB,CADgC,CACF;;EAE9B,IAAI/B,SAAS,CAACwC,MAAD,CAAb,EAAuB;IACrB,MAAM,IAAIQ,KAAJ,CAAU,qDAAV,CAAN;EACD;;EAED,OAAOR,MAAP;AACD;AACD;AACA;AACA;AACA;;AAEA,SAASI,aAAT,CAAuBD,IAAvB,EAA6BL,MAA7B,EAAqC;EACnC,OAAOA,MAAM,CAACL,MAAP,KAAkB,CAAlB,GACH;IACEU;EADF,CADG,GAIH;IACEL,MADF;IAEEK;EAFF,CAJJ;AAQD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAEA,OAAO,SAASP,6BAAT,CACLT,MADK,EAELO,QAFK,EAGLe,iBAHK,EAIL;EACAf,QAAQ,IAAIvC,SAAS,CAAC,KAAD,EAAQ,wBAAR,CAArB,CADA,CACwD;;EAExDuB,iBAAiB,CAACS,MAAD,CAAjB,CAHA,CAG2B;;EAE3BsB,iBAAiB,IAAI,IAArB,IACElD,YAAY,CAACkD,iBAAD,CADd,IAEEtD,SAAS,CACP,KADO,EAEP,+IAFO,CAFX;AAMD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAAS0C,qBAAT,CAA+BN,IAA/B,EAAqC;EAC1C,IAAImB,gBAAJ,EAAsBC,qBAAtB;;EAEA,MAAM;IACJxB,MADI;IAEJO,QAFI;IAGJC,SAHI;IAIJiB,YAJI;IAKJvB,cAAc,EAAEoB,iBALZ;IAMJI,aANI;IAOJC,aAPI;IAQJC,YARI;IASJC;EATI,IAUFzB,IAVJ;EAWA,IAAIQ,SAAJ;EACA,MAAMX,SAAS,GAAG6B,MAAM,CAACC,MAAP,CAAc,IAAd,CAAlB;;EAEA,KAAK,MAAMC,UAAX,IAAyBzB,QAAQ,CAAC0B,WAAlC,EAA+C;IAC7C,QAAQD,UAAU,CAACE,IAAnB;MACE,KAAKpD,IAAI,CAACqD,oBAAV;QACE,IAAIT,aAAa,IAAI,IAArB,EAA2B;UACzB,IAAId,SAAS,KAAKwB,SAAlB,EAA6B;YAC3B,OAAO,CACL,IAAIzD,YAAJ,CACE,oEADF,CADK,CAAP;UAKD;;UAEDiC,SAAS,GAAGoB,UAAZ;QACD,CAVD,MAUO,IACL,CAAC,CAACT,gBAAgB,GAAGS,UAAU,CAACK,IAA/B,MAAyC,IAAzC,IACDd,gBAAgB,KAAK,KAAK,CADzB,GAEG,KAAK,CAFR,GAGGA,gBAAgB,CAACe,KAHrB,MAGgCZ,aAJ3B,EAKL;UACAd,SAAS,GAAGoB,UAAZ;QACD;;QAED;;MAEF,KAAKlD,IAAI,CAACyD,mBAAV;QACEtC,SAAS,CAAC+B,UAAU,CAACK,IAAX,CAAgBC,KAAjB,CAAT,GAAmCN,UAAnC;QACA;;MAEF,QA3BF,CA2BW;;IA3BX;EA6BD;;EAED,IAAI,CAACpB,SAAL,EAAgB;IACd,IAAIc,aAAa,IAAI,IAArB,EAA2B;MACzB,OAAO,CAAC,IAAI/C,YAAJ,CAAkB,4BAA2B+C,aAAc,IAA3D,CAAD,CAAP;IACD;;IAED,OAAO,CAAC,IAAI/C,YAAJ,CAAiB,4BAAjB,CAAD,CAAP;EACD,CAvDyC,CAuDxC;;EAEF;;;EAEA,MAAM6D,mBAAmB,GACvB,CAAChB,qBAAqB,GAAGZ,SAAS,CAAC4B,mBAAnC,MAA4D,IAA5D,IACAhB,qBAAqB,KAAK,KAAK,CAD/B,GAEIA,qBAFJ,GAGI,EAJN;EAKA,MAAMiB,qBAAqB,GAAG7C,iBAAiB,CAC7CI,MAD6C,EAE7CwC,mBAF6C,EAG7ClB,iBAAiB,KAAK,IAAtB,IAA8BA,iBAAiB,KAAK,KAAK,CAAzD,GACIA,iBADJ,GAEI,EALyC,EAM7C;IACEoB,SAAS,EAAE;EADb,CAN6C,CAA/C;;EAWA,IAAID,qBAAqB,CAAC9B,MAA1B,EAAkC;IAChC,OAAO8B,qBAAqB,CAAC9B,MAA7B;EACD;;EAED,OAAO;IACLX,MADK;IAELC,SAFK;IAGLO,SAHK;IAILiB,YAJK;IAKLb,SALK;IAMLV,cAAc,EAAEuC,qBAAqB,CAACE,OANjC;IAOLhB,aAAa,EACXA,aAAa,KAAK,IAAlB,IAA0BA,aAAa,KAAK,KAAK,CAAjD,GACIA,aADJ,GAEIiB,oBAVD;IAWLhB,YAAY,EACVA,YAAY,KAAK,IAAjB,IAAyBA,YAAY,KAAK,KAAK,CAA/C,GACIA,YADJ,GAEIiB,mBAdD;IAeLhB,sBAAsB,EACpBA,sBAAsB,KAAK,IAA3B,IAAmCA,sBAAsB,KAAK,KAAK,CAAnE,GACIA,sBADJ,GAEIe,oBAlBD;IAmBLjC,MAAM,EAAE;EAnBH,CAAP;AAqBD;AACD;AACA;AACA;;AAEA,SAASG,gBAAT,CAA0BjB,UAA1B,EAAsCe,SAAtC,EAAiDJ,SAAjD,EAA4D;EAC1D,MAAMsC,QAAQ,GAAGjD,UAAU,CAACG,MAAX,CAAkB+C,WAAlB,CAA8BnC,SAAS,CAACA,SAAxC,CAAjB;;EAEA,IAAIkC,QAAQ,IAAI,IAAhB,EAAsB;IACpB,MAAM,IAAInE,YAAJ,CACH,uCAAsCiC,SAAS,CAACA,SAAU,aADvD,EAEJ;MACEoC,KAAK,EAAEpC;IADT,CAFI,CAAN;EAMD;;EAED,MAAMqC,UAAU,GAAGzD,aAAa,CAC9BK,UAAU,CAACG,MADmB,EAE9BH,UAAU,CAACI,SAFmB,EAG9BJ,UAAU,CAACK,cAHmB,EAI9B4C,QAJ8B,EAK9BlC,SAAS,CAACsC,YALoB,CAAhC;EAOA,MAAMC,IAAI,GAAGf,SAAb;;EAEA,QAAQxB,SAAS,CAACA,SAAlB;IACE,KAAK/B,iBAAiB,CAACuE,KAAvB;MACE,OAAOC,aAAa,CAACxD,UAAD,EAAaiD,QAAb,EAAuBtC,SAAvB,EAAkC2C,IAAlC,EAAwCF,UAAxC,CAApB;;IAEF,KAAKpE,iBAAiB,CAACyE,QAAvB;MACE,OAAOC,qBAAqB,CAC1B1D,UAD0B,EAE1BiD,QAF0B,EAG1BtC,SAH0B,EAI1B2C,IAJ0B,EAK1BF,UAL0B,CAA5B;;IAQF,KAAKpE,iBAAiB,CAAC2E,YAAvB;MACE;MACA;MACA,OAAOH,aAAa,CAACxD,UAAD,EAAaiD,QAAb,EAAuBtC,SAAvB,EAAkC2C,IAAlC,EAAwCF,UAAxC,CAApB;EAhBJ;AAkBD;AACD;AACA;AACA;AACA;;;AAEA,SAASM,qBAAT,CACE1D,UADF,EAEE4D,UAFF,EAGEC,WAHF,EAIEP,IAJF,EAKEQ,MALF,EAME;EACA,OAAOjF,aAAa,CAClBiF,MAAM,CAACC,OAAP,EADkB,EAElB,CAACC,OAAD,WAAyC;IAAA,IAA/B,CAACC,YAAD,EAAe/D,UAAf,CAA+B;IACvC,MAAMgE,SAAS,GAAGxF,OAAO,CAAC4E,IAAD,EAAOW,YAAP,EAAqBL,UAAU,CAACpB,IAAhC,CAAzB;IACA,MAAMxB,MAAM,GAAGmD,YAAY,CACzBnE,UADyB,EAEzB4D,UAFyB,EAGzBC,WAHyB,EAIzB3D,UAJyB,EAKzBgE,SALyB,CAA3B;;IAQA,IAAIlD,MAAM,KAAKuB,SAAf,EAA0B;MACxB,OAAOyB,OAAP;IACD;;IAED,IAAIxF,SAAS,CAACwC,MAAD,CAAb,EAAuB;MACrB,OAAOA,MAAM,CAACE,IAAP,CAAakD,cAAD,IAAoB;QACrCJ,OAAO,CAACC,YAAD,CAAP,GAAwBG,cAAxB;QACA,OAAOJ,OAAP;MACD,CAHM,CAAP;IAID;;IAEDA,OAAO,CAACC,YAAD,CAAP,GAAwBjD,MAAxB;IACA,OAAOgD,OAAP;EACD,CAzBiB,EA0BlB/B,MAAM,CAACC,MAAP,CAAc,IAAd,CA1BkB,CAApB;AA4BD;AACD;AACA;AACA;AACA;;;AAEA,SAASsB,aAAT,CAAuBxD,UAAvB,EAAmC4D,UAAnC,EAA+CC,WAA/C,EAA4DP,IAA5D,EAAkEQ,MAAlE,EAA0E;EACxE,MAAME,OAAO,GAAG/B,MAAM,CAACC,MAAP,CAAc,IAAd,CAAhB;EACA,IAAImC,eAAe,GAAG,KAAtB;;EAEA,KAAK,MAAM,CAACJ,YAAD,EAAe/D,UAAf,CAAX,IAAyC4D,MAAM,CAACC,OAAP,EAAzC,EAA2D;IACzD,MAAMG,SAAS,GAAGxF,OAAO,CAAC4E,IAAD,EAAOW,YAAP,EAAqBL,UAAU,CAACpB,IAAhC,CAAzB;IACA,MAAMxB,MAAM,GAAGmD,YAAY,CACzBnE,UADyB,EAEzB4D,UAFyB,EAGzBC,WAHyB,EAIzB3D,UAJyB,EAKzBgE,SALyB,CAA3B;;IAQA,IAAIlD,MAAM,KAAKuB,SAAf,EAA0B;MACxByB,OAAO,CAACC,YAAD,CAAP,GAAwBjD,MAAxB;;MAEA,IAAIxC,SAAS,CAACwC,MAAD,CAAb,EAAuB;QACrBqD,eAAe,GAAG,IAAlB;MACD;IACF;EACF,CArBuE,CAqBtE;;;EAEF,IAAI,CAACA,eAAL,EAAsB;IACpB,OAAOL,OAAP;EACD,CAzBuE,CAyBtE;EACF;EACA;;;EAEA,OAAOpF,gBAAgB,CAACoF,OAAD,CAAvB;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASG,YAAT,CAAsBnE,UAAtB,EAAkC4D,UAAlC,EAA8CU,MAA9C,EAAsDpE,UAAtD,EAAkEoD,IAAlE,EAAwE;EACtE,IAAIiB,iBAAJ;;EAEA,MAAMC,QAAQ,GAAGC,WAAW,CAACzE,UAAU,CAACG,MAAZ,EAAoByD,UAApB,EAAgC1D,UAAU,CAAC,CAAD,CAA1C,CAA5B;;EAEA,IAAI,CAACsE,QAAL,EAAe;IACb;EACD;;EAED,MAAMvE,UAAU,GAAGuE,QAAQ,CAACE,IAA5B;EACA,MAAMC,SAAS,GACb,CAACJ,iBAAiB,GAAGC,QAAQ,CAACI,OAA9B,MAA2C,IAA3C,IACAL,iBAAiB,KAAK,KAAK,CAD3B,GAEIA,iBAFJ,GAGIvE,UAAU,CAAC8B,aAJjB;EAKA,MAAM+C,IAAI,GAAGC,gBAAgB,CAC3B9E,UAD2B,EAE3BwE,QAF2B,EAG3BtE,UAH2B,EAI3B0D,UAJ2B,EAK3BN,IAL2B,CAA7B,CAfsE,CAqBnE;;EAEH,IAAI;IACF;IACA;IACA;IACA,MAAM/C,IAAI,GAAGT,iBAAiB,CAC5B0E,QAD4B,EAE5BtE,UAAU,CAAC,CAAD,CAFkB,EAG5BF,UAAU,CAACK,cAHiB,CAA9B,CAJE,CAQC;IACH;IACA;;IAEA,MAAMuB,YAAY,GAAG5B,UAAU,CAAC4B,YAAhC;IACA,MAAMZ,MAAM,GAAG2D,SAAS,CAACL,MAAD,EAAS/D,IAAT,EAAeqB,YAAf,EAA6BiD,IAA7B,CAAxB;IACA,IAAIE,SAAJ;;IAEA,IAAIvG,SAAS,CAACwC,MAAD,CAAb,EAAuB;MACrB+D,SAAS,GAAG/D,MAAM,CAACE,IAAP,CAAa8D,QAAD,IACtBC,aAAa,CAACjF,UAAD,EAAaC,UAAb,EAAyBC,UAAzB,EAAqC2E,IAArC,EAA2CvB,IAA3C,EAAiD0B,QAAjD,CADH,CAAZ;IAGD,CAJD,MAIO;MACLD,SAAS,GAAGE,aAAa,CACvBjF,UADuB,EAEvBC,UAFuB,EAGvBC,UAHuB,EAIvB2E,IAJuB,EAKvBvB,IALuB,EAMvBtC,MANuB,CAAzB;IAQD;;IAED,IAAIxC,SAAS,CAACuG,SAAD,CAAb,EAA0B;MACxB;MACA;MACA,OAAOA,SAAS,CAAC7D,IAAV,CAAeqB,SAAf,EAA2B2C,QAAD,IAAc;QAC7C,MAAM7D,KAAK,GAAGtC,YAAY,CAACmG,QAAD,EAAWhF,UAAX,EAAuBvB,WAAW,CAAC2E,IAAD,CAAlC,CAA1B;QACA,OAAO6B,gBAAgB,CAAC9D,KAAD,EAAQpB,UAAR,EAAoBD,UAApB,CAAvB;MACD,CAHM,CAAP;IAID;;IAED,OAAO+E,SAAP;EACD,CAzCD,CAyCE,OAAOG,QAAP,EAAiB;IACjB,MAAM7D,KAAK,GAAGtC,YAAY,CAACmG,QAAD,EAAWhF,UAAX,EAAuBvB,WAAW,CAAC2E,IAAD,CAAlC,CAA1B;IACA,OAAO6B,gBAAgB,CAAC9D,KAAD,EAAQpB,UAAR,EAAoBD,UAApB,CAAvB;EACD;AACF;AACD;AACA;AACA;;;AAEA,OAAO,SAAS8E,gBAAT,CACL9E,UADK,EAELwE,QAFK,EAGLtE,UAHK,EAIL0D,UAJK,EAKLN,IALK,EAML;EACA;EACA;EACA,OAAO;IACL8B,SAAS,EAAEZ,QAAQ,CAAChC,IADf;IAELtC,UAFK;IAGLD,UAAU,EAAEuE,QAAQ,CAACE,IAHhB;IAILd,UAJK;IAKLN,IALK;IAMLnD,MAAM,EAAEH,UAAU,CAACG,MANd;IAOLC,SAAS,EAAEJ,UAAU,CAACI,SAPjB;IAQLO,SAAS,EAAEX,UAAU,CAACW,SARjB;IASLI,SAAS,EAAEf,UAAU,CAACe,SATjB;IAULV,cAAc,EAAEL,UAAU,CAACK;EAVtB,CAAP;AAYD;;AAED,SAAS8E,gBAAT,CAA0B9D,KAA1B,EAAiCpB,UAAjC,EAA6CD,UAA7C,EAAyD;EACvD;EACA;EACA,IAAIX,aAAa,CAACY,UAAD,CAAjB,EAA+B;IAC7B,MAAMoB,KAAN;EACD,CALsD,CAKrD;EACF;;;EAEArB,UAAU,CAACc,MAAX,CAAkBQ,IAAlB,CAAuBD,KAAvB;EACA,OAAO,IAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAAS4D,aAAT,CAAuBjF,UAAvB,EAAmCC,UAAnC,EAA+CC,UAA/C,EAA2D2E,IAA3D,EAAiEvB,IAAjE,EAAuEtC,MAAvE,EAA+E;EAC7E;EACA,IAAIA,MAAM,YAAYQ,KAAtB,EAA6B;IAC3B,MAAMR,MAAN;EACD,CAJ4E,CAI3E;EACF;;;EAEA,IAAI3B,aAAa,CAACY,UAAD,CAAjB,EAA+B;IAC7B,MAAM8E,SAAS,GAAGE,aAAa,CAC7BjF,UAD6B,EAE7BC,UAAU,CAACoF,MAFkB,EAG7BnF,UAH6B,EAI7B2E,IAJ6B,EAK7BvB,IAL6B,EAM7BtC,MAN6B,CAA/B;;IASA,IAAI+D,SAAS,KAAK,IAAlB,EAAwB;MACtB,MAAM,IAAIvD,KAAJ,CACH,6CAA4CqD,IAAI,CAACjB,UAAL,CAAgBpB,IAAK,IAAGqC,IAAI,CAACO,SAAU,GADhF,CAAN;IAGD;;IAED,OAAOL,SAAP;EACD,CAxB4E,CAwB3E;;;EAEF,IAAI/D,MAAM,IAAI,IAAd,EAAoB;IAClB,OAAO,IAAP;EACD,CA5B4E,CA4B3E;;;EAEF,IAAI5B,UAAU,CAACa,UAAD,CAAd,EAA4B;IAC1B,OAAOqF,iBAAiB,CACtBtF,UADsB,EAEtBC,UAFsB,EAGtBC,UAHsB,EAItB2E,IAJsB,EAKtBvB,IALsB,EAMtBtC,MANsB,CAAxB;EAQD,CAvC4E,CAuC3E;EACF;;;EAEA,IAAI7B,UAAU,CAACc,UAAD,CAAd,EAA4B;IAC1B,OAAOsF,iBAAiB,CAACtF,UAAD,EAAae,MAAb,CAAxB;EACD,CA5C4E,CA4C3E;EACF;;;EAEA,IAAI9B,cAAc,CAACe,UAAD,CAAlB,EAAgC;IAC9B,OAAOuF,qBAAqB,CAC1BxF,UAD0B,EAE1BC,UAF0B,EAG1BC,UAH0B,EAI1B2E,IAJ0B,EAK1BvB,IAL0B,EAM1BtC,MAN0B,CAA5B;EAQD,CAxD4E,CAwD3E;;;EAEF,IAAI1B,YAAY,CAACW,UAAD,CAAhB,EAA8B;IAC5B,OAAOwF,mBAAmB,CACxBzF,UADwB,EAExBC,UAFwB,EAGxBC,UAHwB,EAIxB2E,IAJwB,EAKxBvB,IALwB,EAMxBtC,MANwB,CAA1B;EAQD;EACD;EACA;;;EAEA,SACE3C,SAAS,CACP,KADO,EAEP,sDAAsDD,OAAO,CAAC6B,UAAD,CAFtD,CADX;AAKD;AACD;AACA;AACA;AACA;;;AAEA,SAASqF,iBAAT,CACEtF,UADF,EAEEC,UAFF,EAGEC,UAHF,EAIE2E,IAJF,EAKEvB,IALF,EAMEtC,MANF,EAOE;EACA,IAAI,CAAC1C,gBAAgB,CAAC0C,MAAD,CAArB,EAA+B;IAC7B,MAAM,IAAIlC,YAAJ,CACH,sDAAqD+F,IAAI,CAACjB,UAAL,CAAgBpB,IAAK,IAAGqC,IAAI,CAACO,SAAU,IADzF,CAAN;EAGD,CALD,CAKE;EACF;;;EAEA,MAAMM,QAAQ,GAAGzF,UAAU,CAACoF,MAA5B;EACA,IAAIhB,eAAe,GAAG,KAAtB;EACA,MAAMsB,gBAAgB,GAAGC,KAAK,CAACC,IAAN,CAAW7E,MAAX,EAAmB,CAAC8E,IAAD,EAAOC,KAAP,KAAiB;IAC3D;IACA;IACA,MAAMC,QAAQ,GAAGtH,OAAO,CAAC4E,IAAD,EAAOyC,KAAP,EAAcxD,SAAd,CAAxB;;IAEA,IAAI;MACF,IAAI0D,aAAJ;;MAEA,IAAIzH,SAAS,CAACsH,IAAD,CAAb,EAAqB;QACnBG,aAAa,GAAGH,IAAI,CAAC5E,IAAL,CAAW8D,QAAD,IACxBC,aAAa,CACXjF,UADW,EAEX0F,QAFW,EAGXxF,UAHW,EAIX2E,IAJW,EAKXmB,QALW,EAMXhB,QANW,CADC,CAAhB;MAUD,CAXD,MAWO;QACLiB,aAAa,GAAGhB,aAAa,CAC3BjF,UAD2B,EAE3B0F,QAF2B,EAG3BxF,UAH2B,EAI3B2E,IAJ2B,EAK3BmB,QAL2B,EAM3BF,IAN2B,CAA7B;MAQD;;MAED,IAAItH,SAAS,CAACyH,aAAD,CAAb,EAA8B;QAC5B5B,eAAe,GAAG,IAAlB,CAD4B,CACJ;QACxB;;QAEA,OAAO4B,aAAa,CAAC/E,IAAd,CAAmBqB,SAAnB,EAA+B2C,QAAD,IAAc;UACjD,MAAM7D,KAAK,GAAGtC,YAAY,CACxBmG,QADwB,EAExBhF,UAFwB,EAGxBvB,WAAW,CAACqH,QAAD,CAHa,CAA1B;UAKA,OAAOb,gBAAgB,CAAC9D,KAAD,EAAQqE,QAAR,EAAkB1F,UAAlB,CAAvB;QACD,CAPM,CAAP;MAQD;;MAED,OAAOiG,aAAP;IACD,CAxCD,CAwCE,OAAOf,QAAP,EAAiB;MACjB,MAAM7D,KAAK,GAAGtC,YAAY,CAACmG,QAAD,EAAWhF,UAAX,EAAuBvB,WAAW,CAACqH,QAAD,CAAlC,CAA1B;MACA,OAAOb,gBAAgB,CAAC9D,KAAD,EAAQqE,QAAR,EAAkB1F,UAAlB,CAAvB;IACD;EACF,CAjDwB,CAAzB;EAkDA,OAAOqE,eAAe,GAAG6B,OAAO,CAACC,GAAR,CAAYR,gBAAZ,CAAH,GAAmCA,gBAAzD;AACD;AACD;AACA;AACA;AACA;;;AAEA,SAASJ,iBAAT,CAA2BtF,UAA3B,EAAuCe,MAAvC,EAA+C;EAC7C,MAAMoF,gBAAgB,GAAGnG,UAAU,CAACoG,SAAX,CAAqBrF,MAArB,CAAzB;;EAEA,IAAIoF,gBAAgB,IAAI,IAAxB,EAA8B;IAC5B,MAAM,IAAI5E,KAAJ,CACH,cAAapD,OAAO,CAAC6B,UAAD,CAAa,cAAa7B,OAAO,CAAC4C,MAAD,CAAS,SAA/D,GACG,wCAAuC5C,OAAO,CAACgI,gBAAD,CAAmB,EAFhE,CAAN;EAID;;EAED,OAAOA,gBAAP;AACD;AACD;AACA;AACA;AACA;;;AAEA,SAASZ,qBAAT,CACExF,UADF,EAEEC,UAFF,EAGEC,UAHF,EAIE2E,IAJF,EAKEvB,IALF,EAMEtC,MANF,EAOE;EACA,IAAIsF,qBAAJ;;EAEA,MAAMC,aAAa,GACjB,CAACD,qBAAqB,GAAGrG,UAAU,CAACuG,WAApC,MAAqD,IAArD,IACAF,qBAAqB,KAAK,KAAK,CAD/B,GAEIA,qBAFJ,GAGItG,UAAU,CAAC+B,YAJjB;EAKA,MAAMH,YAAY,GAAG5B,UAAU,CAAC4B,YAAhC;EACA,MAAM6E,WAAW,GAAGF,aAAa,CAACvF,MAAD,EAASY,YAAT,EAAuBiD,IAAvB,EAA6B5E,UAA7B,CAAjC;;EAEA,IAAIzB,SAAS,CAACiI,WAAD,CAAb,EAA4B;IAC1B,OAAOA,WAAW,CAACvF,IAAZ,CAAkBwF,mBAAD,IACtBjB,mBAAmB,CACjBzF,UADiB,EAEjB2G,sBAAsB,CACpBD,mBADoB,EAEpB1G,UAFoB,EAGpBC,UAHoB,EAIpBC,UAJoB,EAKpB2E,IALoB,EAMpB7D,MANoB,CAFL,EAUjBd,UAViB,EAWjB2E,IAXiB,EAYjBvB,IAZiB,EAajBtC,MAbiB,CADd,CAAP;EAiBD;;EAED,OAAOyE,mBAAmB,CACxBzF,UADwB,EAExB2G,sBAAsB,CACpBF,WADoB,EAEpBzG,UAFoB,EAGpBC,UAHoB,EAIpBC,UAJoB,EAKpB2E,IALoB,EAMpB7D,MANoB,CAFE,EAUxBd,UAVwB,EAWxB2E,IAXwB,EAYxBvB,IAZwB,EAaxBtC,MAbwB,CAA1B;AAeD;;AAED,SAAS2F,sBAAT,CACEC,eADF,EAEE5G,UAFF,EAGEC,UAHF,EAIEC,UAJF,EAKE2E,IALF,EAME7D,MANF,EAOE;EACA,IAAI4F,eAAe,IAAI,IAAvB,EAA6B;IAC3B,MAAM,IAAI9H,YAAJ,CACH,kBAAiBmB,UAAU,CAACuC,IAAK,0DAAyDqC,IAAI,CAACjB,UAAL,CAAgBpB,IAAK,IAAGqC,IAAI,CAACO,SAAU,kBAAiBnF,UAAU,CAACuC,IAAK,6GAD/J,EAEJtC,UAFI,CAAN;EAID,CAND,CAME;EACF;;;EAEA,IAAIZ,YAAY,CAACsH,eAAD,CAAhB,EAAmC;IACjC,MAAM,IAAI9H,YAAJ,CACJ,4HADI,CAAN;EAGD;;EAED,IAAI,OAAO8H,eAAP,KAA2B,QAA/B,EAAyC;IACvC,MAAM,IAAI9H,YAAJ,CACH,kBAAiBmB,UAAU,CAACuC,IAAK,0DAAyDqC,IAAI,CAACjB,UAAL,CAAgBpB,IAAK,IAAGqC,IAAI,CAACO,SAAU,SAAlI,GACG,SAAQhH,OAAO,CAAC4C,MAAD,CAAS,eAAc5C,OAAO,CAACwI,eAAD,CAAkB,IAF9D,CAAN;EAID;;EAED,MAAMH,WAAW,GAAGzG,UAAU,CAACG,MAAX,CAAkB0G,OAAlB,CAA0BD,eAA1B,CAApB;;EAEA,IAAIH,WAAW,IAAI,IAAnB,EAAyB;IACvB,MAAM,IAAI3H,YAAJ,CACH,kBAAiBmB,UAAU,CAACuC,IAAK,6BAA4BoE,eAAgB,0CAD1E,EAEJ;MACEzD,KAAK,EAAEjD;IADT,CAFI,CAAN;EAMD;;EAED,IAAI,CAACZ,YAAY,CAACmH,WAAD,CAAjB,EAAgC;IAC9B,MAAM,IAAI3H,YAAJ,CACH,kBAAiBmB,UAAU,CAACuC,IAAK,wCAAuCoE,eAAgB,IADrF,EAEJ;MACEzD,KAAK,EAAEjD;IADT,CAFI,CAAN;EAMD;;EAED,IAAI,CAACF,UAAU,CAACG,MAAX,CAAkB2G,SAAlB,CAA4B7G,UAA5B,EAAwCwG,WAAxC,CAAL,EAA2D;IACzD,MAAM,IAAI3H,YAAJ,CACH,wBAAuB2H,WAAW,CAACjE,IAAK,iCAAgCvC,UAAU,CAACuC,IAAK,IADrF,EAEJ;MACEW,KAAK,EAAEjD;IADT,CAFI,CAAN;EAMD;;EAED,OAAOuG,WAAP;AACD;AACD;AACA;AACA;;;AAEA,SAAShB,mBAAT,CACEzF,UADF,EAEEC,UAFF,EAGEC,UAHF,EAIE2E,IAJF,EAKEvB,IALF,EAMEtC,MANF,EAOE;EACA;EACA,MAAM+F,aAAa,GAAGnH,gBAAgB,CAACI,UAAD,EAAaC,UAAb,EAAyBC,UAAzB,CAAtC,CAFA,CAE4E;EAC5E;EACA;;EAEA,IAAID,UAAU,CAAC+G,QAAf,EAAyB;IACvB,MAAMA,QAAQ,GAAG/G,UAAU,CAAC+G,QAAX,CAAoBhG,MAApB,EAA4BhB,UAAU,CAAC4B,YAAvC,EAAqDiD,IAArD,CAAjB;;IAEA,IAAIrG,SAAS,CAACwI,QAAD,CAAb,EAAyB;MACvB,OAAOA,QAAQ,CAAC9F,IAAT,CAAe+F,gBAAD,IAAsB;QACzC,IAAI,CAACA,gBAAL,EAAuB;UACrB,MAAMC,sBAAsB,CAACjH,UAAD,EAAae,MAAb,EAAqBd,UAArB,CAA5B;QACD;;QAED,OAAOsD,aAAa,CAClBxD,UADkB,EAElBC,UAFkB,EAGlBe,MAHkB,EAIlBsC,IAJkB,EAKlByD,aALkB,CAApB;MAOD,CAZM,CAAP;IAaD;;IAED,IAAI,CAACC,QAAL,EAAe;MACb,MAAME,sBAAsB,CAACjH,UAAD,EAAae,MAAb,EAAqBd,UAArB,CAA5B;IACD;EACF;;EAED,OAAOsD,aAAa,CAACxD,UAAD,EAAaC,UAAb,EAAyBe,MAAzB,EAAiCsC,IAAjC,EAAuCyD,aAAvC,CAApB;AACD;;AAED,SAASG,sBAAT,CAAgCjH,UAAhC,EAA4Ce,MAA5C,EAAoDd,UAApD,EAAgE;EAC9D,OAAO,IAAIpB,YAAJ,CACJ,2BAA0BmB,UAAU,CAACuC,IAAK,cAAapE,OAAO,CAAC4C,MAAD,CAAS,GADnE,EAEL;IACEmC,KAAK,EAAEjD;EADT,CAFK,CAAP;AAMD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,OAAO,MAAM8C,mBAAmB,GAAG,UACjCP,KADiC,EAEjCb,YAFiC,EAGjCiD,IAHiC,EAIjCsC,YAJiC,EAKjC;EACA;EACA,IAAI5I,YAAY,CAACkE,KAAD,CAAZ,IAAuB,OAAOA,KAAK,CAAC2E,UAAb,KAA4B,QAAvD,EAAiE;IAC/D,OAAO3E,KAAK,CAAC2E,UAAb;EACD,CAJD,CAIE;;;EAEF,MAAMC,aAAa,GAAGxC,IAAI,CAAC1E,MAAL,CAAYmH,gBAAZ,CAA6BH,YAA7B,CAAtB;EACA,MAAMI,uBAAuB,GAAG,EAAhC;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,aAAa,CAAC5G,MAAlC,EAA0C+G,CAAC,EAA3C,EAA+C;IAC7C,MAAM9C,IAAI,GAAG2C,aAAa,CAACG,CAAD,CAA1B;;IAEA,IAAI9C,IAAI,CAACsC,QAAT,EAAmB;MACjB,MAAMS,cAAc,GAAG/C,IAAI,CAACsC,QAAL,CAAcvE,KAAd,EAAqBb,YAArB,EAAmCiD,IAAnC,CAAvB;;MAEA,IAAIrG,SAAS,CAACiJ,cAAD,CAAb,EAA+B;QAC7BF,uBAAuB,CAACC,CAAD,CAAvB,GAA6BC,cAA7B;MACD,CAFD,MAEO,IAAIA,cAAJ,EAAoB;QACzB,OAAO/C,IAAI,CAAClC,IAAZ;MACD;IACF;EACF;;EAED,IAAI+E,uBAAuB,CAAC9G,MAA5B,EAAoC;IAClC,OAAOyF,OAAO,CAACC,GAAR,CAAYoB,uBAAZ,EAAqCrG,IAArC,CAA2CwG,eAAD,IAAqB;MACpE,KAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGE,eAAe,CAACjH,MAApC,EAA4C+G,CAAC,EAA7C,EAAiD;QAC/C,IAAIE,eAAe,CAACF,CAAD,CAAnB,EAAwB;UACtB,OAAOH,aAAa,CAACG,CAAD,CAAb,CAAiBhF,IAAxB;QACD;MACF;IACF,CANM,CAAP;EAOD;AACF,CArCM;AAsCP;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMO,oBAAoB,GAAG,UAClCuB,MADkC,EAElC/D,IAFkC,EAGlCqB,YAHkC,EAIlCiD,IAJkC,EAKlC;EACA;EACA,IAAItG,YAAY,CAAC+F,MAAD,CAAZ,IAAwB,OAAOA,MAAP,KAAkB,UAA9C,EAA0D;IACxD,MAAMqD,QAAQ,GAAGrD,MAAM,CAACO,IAAI,CAACO,SAAN,CAAvB;;IAEA,IAAI,OAAOuC,QAAP,KAAoB,UAAxB,EAAoC;MAClC,OAAOrD,MAAM,CAACO,IAAI,CAACO,SAAN,CAAN,CAAuB7E,IAAvB,EAA6BqB,YAA7B,EAA2CiD,IAA3C,CAAP;IACD;;IAED,OAAO8C,QAAP;EACD;AACF,CAhBM;AAiBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASlD,WAAT,CAAqBtE,MAArB,EAA6ByD,UAA7B,EAAyCgE,SAAzC,EAAoD;EACzD,MAAMxC,SAAS,GAAGwC,SAAS,CAACpF,IAAV,CAAeC,KAAjC;;EAEA,IACE2C,SAAS,KAAK7F,kBAAkB,CAACiD,IAAjC,IACArC,MAAM,CAAC0H,YAAP,OAA0BjE,UAF5B,EAGE;IACA,OAAOrE,kBAAP;EACD,CALD,MAKO,IACL6F,SAAS,KAAK5F,gBAAgB,CAACgD,IAA/B,IACArC,MAAM,CAAC0H,YAAP,OAA0BjE,UAFrB,EAGL;IACA,OAAOpE,gBAAP;EACD,CALM,MAKA,IAAI4F,SAAS,KAAK3F,oBAAoB,CAAC+C,IAAvC,EAA6C;IAClD,OAAO/C,oBAAP;EACD;;EAED,OAAOmE,UAAU,CAACkE,SAAX,GAAuB1C,SAAvB,CAAP;AACD"},"metadata":{},"sourceType":"module"}