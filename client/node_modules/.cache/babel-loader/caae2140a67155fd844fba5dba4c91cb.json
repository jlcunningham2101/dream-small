{"ast":null,"code":"import objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport keyValMap from \"../jsutils/keyValMap.mjs\";\nimport isObjectLike from \"../jsutils/isObjectLike.mjs\";\nimport { parseValue } from \"../language/parser.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { GraphQLDirective } from \"../type/directives.mjs\";\nimport { specifiedScalarTypes } from \"../type/scalars.mjs\";\nimport { introspectionTypes, TypeKind } from \"../type/introspection.mjs\";\nimport { isInputType, isOutputType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, assertNullableType, assertObjectType, assertInterfaceType } from \"../type/definition.mjs\";\nimport { valueFromAST } from \"./valueFromAST.mjs\";\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(0, \"Invalid or incomplete introspection result. Ensure that you are passing \\\"data\\\" property of introspection response and no \\\"errors\\\" was returned alongside: \".concat(inspect(introspection), \".\")); // Get the schema from the introspection result.\n\n  var schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  var typeMap = keyValMap(schemaIntrospection.types, function (typeIntrospection) {\n    return typeIntrospection.name;\n  }, function (typeIntrospection) {\n    return buildType(typeIntrospection);\n  }); // Include standard types only if they are used.\n\n  for (var _i2 = 0, _ref2 = [].concat(specifiedScalarTypes, introspectionTypes); _i2 < _ref2.length; _i2++) {\n    var stdType = _ref2[_i2];\n\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: objectValues(typeMap),\n    directives: directives,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return new GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      return new GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    var typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(\"Unknown type reference: \".concat(inspect(typeRef), \".\"));\n    }\n\n    var type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure that a full introspection query is used in order to build a client schema.\"));\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    if (type != null && type.name != null && type.kind != null) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    var typeStr = inspect(type);\n    throw new Error(\"Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: \".concat(typeStr, \".\"));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByUrl: scalarIntrospection.specifiedByUrl\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      var implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(\"Introspection result missing interfaces: \".concat(implementingIntrospectionStr, \".\"));\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(objectIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(interfaceIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      var unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(\"Introspection result missing possibleTypes: \".concat(unionIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: function types() {\n        return unionIntrospection.possibleTypes.map(getObjectType);\n      }\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      var enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(\"Introspection result missing enumValues: \".concat(enumIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      var inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(\"Introspection result missing inputFields: \".concat(inputObjectIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\"Introspection result missing fields: \".concat(inspect(typeIntrospection), \".\"));\n    }\n\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, buildField);\n  }\n\n  function buildField(fieldIntrospection) {\n    var type = getType(fieldIntrospection.type);\n\n    if (!isOutputType(type)) {\n      var typeStr = inspect(type);\n      throw new Error(\"Introspection must provide output type for fields, but received: \".concat(typeStr, \".\"));\n    }\n\n    if (!fieldIntrospection.args) {\n      var fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(\"Introspection result missing field args: \".concat(fieldIntrospectionStr, \".\"));\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type: type,\n      args: buildInputValueDefMap(fieldIntrospection.args)\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getType(inputValueIntrospection.type);\n\n    if (!isInputType(type)) {\n      var typeStr = inspect(type);\n      throw new Error(\"Introspection must provide input type for arguments, but received: \".concat(typeStr, \".\"));\n    }\n\n    var defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      var directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\"Introspection result missing directive args: \".concat(directiveIntrospectionStr, \".\"));\n    }\n\n    if (!directiveIntrospection.locations) {\n      var _directiveIntrospectionStr = inspect(directiveIntrospection);\n\n      throw new Error(\"Introspection result missing directive locations: \".concat(_directiveIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n}","map":{"version":3,"names":["objectValues","inspect","devAssert","keyValMap","isObjectLike","parseValue","GraphQLSchema","GraphQLDirective","specifiedScalarTypes","introspectionTypes","TypeKind","isInputType","isOutputType","GraphQLList","GraphQLNonNull","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","assertNullableType","assertObjectType","assertInterfaceType","valueFromAST","buildClientSchema","introspection","options","__schema","concat","schemaIntrospection","typeMap","types","typeIntrospection","name","buildType","_i2","_ref2","length","stdType","queryType","getObjectType","mutationType","subscriptionType","directives","map","buildDirective","description","query","mutation","subscription","assumeValid","getType","typeRef","kind","LIST","itemRef","ofType","Error","NON_NULL","nullableRef","nullableType","getNamedType","typeName","type","getInterfaceType","SCALAR","buildScalarDef","OBJECT","buildObjectDef","INTERFACE","buildInterfaceDef","UNION","buildUnionDef","ENUM","buildEnumDef","INPUT_OBJECT","buildInputObjectDef","typeStr","scalarIntrospection","specifiedByUrl","buildImplementationsList","implementingIntrospection","interfaces","implementingIntrospectionStr","objectIntrospection","fields","buildFieldDefMap","interfaceIntrospection","unionIntrospection","possibleTypes","unionIntrospectionStr","enumIntrospection","enumValues","enumIntrospectionStr","values","valueIntrospection","deprecationReason","inputObjectIntrospection","inputFields","inputObjectIntrospectionStr","buildInputValueDefMap","fieldIntrospection","buildField","args","fieldIntrospectionStr","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","defaultValue","undefined","directiveIntrospection","directiveIntrospectionStr","locations","_directiveIntrospectionStr","isRepeatable","slice"],"sources":["C:/Users/jleig/Desktop/challenges/dream-small/client/node_modules/graphql/utilities/buildClientSchema.mjs"],"sourcesContent":["import objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport keyValMap from \"../jsutils/keyValMap.mjs\";\nimport isObjectLike from \"../jsutils/isObjectLike.mjs\";\nimport { parseValue } from \"../language/parser.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { GraphQLDirective } from \"../type/directives.mjs\";\nimport { specifiedScalarTypes } from \"../type/scalars.mjs\";\nimport { introspectionTypes, TypeKind } from \"../type/introspection.mjs\";\nimport { isInputType, isOutputType, GraphQLList, GraphQLNonNull, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, assertNullableType, assertObjectType, assertInterfaceType } from \"../type/definition.mjs\";\nimport { valueFromAST } from \"./valueFromAST.mjs\";\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(0, \"Invalid or incomplete introspection result. Ensure that you are passing \\\"data\\\" property of introspection response and no \\\"errors\\\" was returned alongside: \".concat(inspect(introspection), \".\")); // Get the schema from the introspection result.\n\n  var schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  var typeMap = keyValMap(schemaIntrospection.types, function (typeIntrospection) {\n    return typeIntrospection.name;\n  }, function (typeIntrospection) {\n    return buildType(typeIntrospection);\n  }); // Include standard types only if they are used.\n\n  for (var _i2 = 0, _ref2 = [].concat(specifiedScalarTypes, introspectionTypes); _i2 < _ref2.length; _i2++) {\n    var stdType = _ref2[_i2];\n\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: objectValues(typeMap),\n    directives: directives,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return new GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      return new GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    var typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(\"Unknown type reference: \".concat(inspect(typeRef), \".\"));\n    }\n\n    var type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure that a full introspection query is used in order to build a client schema.\"));\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    if (type != null && type.name != null && type.kind != null) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    var typeStr = inspect(type);\n    throw new Error(\"Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: \".concat(typeStr, \".\"));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByUrl: scalarIntrospection.specifiedByUrl\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      var implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(\"Introspection result missing interfaces: \".concat(implementingIntrospectionStr, \".\"));\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(objectIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(interfaceIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      var unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(\"Introspection result missing possibleTypes: \".concat(unionIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: function types() {\n        return unionIntrospection.possibleTypes.map(getObjectType);\n      }\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      var enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(\"Introspection result missing enumValues: \".concat(enumIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      var inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(\"Introspection result missing inputFields: \".concat(inputObjectIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\"Introspection result missing fields: \".concat(inspect(typeIntrospection), \".\"));\n    }\n\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, buildField);\n  }\n\n  function buildField(fieldIntrospection) {\n    var type = getType(fieldIntrospection.type);\n\n    if (!isOutputType(type)) {\n      var typeStr = inspect(type);\n      throw new Error(\"Introspection must provide output type for fields, but received: \".concat(typeStr, \".\"));\n    }\n\n    if (!fieldIntrospection.args) {\n      var fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(\"Introspection result missing field args: \".concat(fieldIntrospectionStr, \".\"));\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type: type,\n      args: buildInputValueDefMap(fieldIntrospection.args)\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getType(inputValueIntrospection.type);\n\n    if (!isInputType(type)) {\n      var typeStr = inspect(type);\n      throw new Error(\"Introspection must provide input type for arguments, but received: \".concat(typeStr, \".\"));\n    }\n\n    var defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      var directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\"Introspection result missing directive args: \".concat(directiveIntrospectionStr, \".\"));\n    }\n\n    if (!directiveIntrospection.locations) {\n      var _directiveIntrospectionStr = inspect(directiveIntrospection);\n\n      throw new Error(\"Introspection result missing directive locations: \".concat(_directiveIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}