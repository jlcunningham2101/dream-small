{"ast":null,"code":"import { Kind } from \"../language/kinds.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var definitionNode = _documentAST$definiti2[_i2];\n\n    switch (definitionNode.kind) {\n      case Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);\n        break;\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n\n  var separatedDocumentASTs = Object.create(null);\n\n  var _loop = function _loop(_i4) {\n    var operation = operations[_i4];\n    var dependencies = new Set();\n\n    for (var _i6 = 0, _collectDependencies2 = collectDependencies(operation.selectionSet); _i6 < _collectDependencies2.length; _i6++) {\n      var fragmentName = _collectDependencies2[_i6];\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n\n    var operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(function (node) {\n        return node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value);\n      })\n    };\n  };\n\n  for (var _i4 = 0; _i4 < operations.length; _i4++) {\n    _loop(_i4);\n  }\n\n  return separatedDocumentASTs;\n} // From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\n\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    var immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (var _i8 = 0; _i8 < immediateDeps.length; _i8++) {\n        var toName = immediateDeps[_i8];\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  var dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread: function FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    }\n  });\n  return dependencies;\n}","map":{"version":3,"names":["Kind","visit","separateOperations","documentAST","operations","depGraph","Object","create","_i2","_documentAST$definiti2","definitions","length","definitionNode","kind","OPERATION_DEFINITION","push","FRAGMENT_DEFINITION","name","value","collectDependencies","selectionSet","separatedDocumentASTs","_loop","_i4","operation","dependencies","Set","_i6","_collectDependencies2","fragmentName","collectTransitiveDependencies","operationName","DOCUMENT","filter","node","has","collected","fromName","add","immediateDeps","undefined","_i8","toName","FragmentSpread"],"sources":["C:/Users/jleig/Desktop/challenges/dream-small/client/node_modules/graphql/utilities/separateOperations.mjs"],"sourcesContent":["import { Kind } from \"../language/kinds.mjs\";\nimport { visit } from \"../language/visitor.mjs\";\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {\n    var definitionNode = _documentAST$definiti2[_i2];\n\n    switch (definitionNode.kind) {\n      case Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);\n        break;\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n\n  var separatedDocumentASTs = Object.create(null);\n\n  var _loop = function _loop(_i4) {\n    var operation = operations[_i4];\n    var dependencies = new Set();\n\n    for (var _i6 = 0, _collectDependencies2 = collectDependencies(operation.selectionSet); _i6 < _collectDependencies2.length; _i6++) {\n      var fragmentName = _collectDependencies2[_i6];\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n\n    var operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(function (node) {\n        return node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value);\n      })\n    };\n  };\n\n  for (var _i4 = 0; _i4 < operations.length; _i4++) {\n    _loop(_i4);\n  }\n\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    var immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (var _i8 = 0; _i8 < immediateDeps.length; _i8++) {\n        var toName = immediateDeps[_i8];\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  var dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread: function FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    }\n  });\n  return dependencies;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}