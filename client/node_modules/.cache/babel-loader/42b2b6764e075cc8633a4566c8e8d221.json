{"ast":null,"code":"import didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isTypeDefinitionNode, isTypeSystemDefinitionNode, isTypeSystemExtensionNode } from \"../../language/predicates.mjs\";\nimport { specifiedScalarTypes } from \"../../type/scalars.mjs\";\nimport { introspectionTypes } from \"../../type/introspection.mjs\";\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n */\n\nexport function KnownTypeNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));\n  return {\n    NamedType: function NamedType(node, _1, parent, _2, ancestors) {\n      var typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;\n        var isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && isStandardTypeName(typeName)) {\n          return;\n        }\n\n        var suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);\n        context.reportError(new GraphQLError(\"Unknown type \\\"\".concat(typeName, \"\\\".\") + didYouMean(suggestedTypes), node));\n      }\n    }\n  };\n}\nvar standardTypeNames = [].concat(specifiedScalarTypes, introspectionTypes).map(function (type) {\n  return type.name;\n});\n\nfunction isStandardTypeName(typeName) {\n  return standardTypeNames.indexOf(typeName) !== -1;\n}\n\nfunction isSDLNode(value) {\n  return !Array.isArray(value) && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));\n}","map":{"version":3,"names":["didYouMean","suggestionList","GraphQLError","isTypeDefinitionNode","isTypeSystemDefinitionNode","isTypeSystemExtensionNode","specifiedScalarTypes","introspectionTypes","KnownTypeNamesRule","context","schema","getSchema","existingTypesMap","getTypeMap","Object","create","definedTypes","_i2","_context$getDocument$2","getDocument","definitions","length","def","name","value","typeNames","keys","concat","NamedType","node","_1","parent","_2","ancestors","typeName","_ancestors$","definitionNode","isSDL","isSDLNode","isStandardTypeName","suggestedTypes","standardTypeNames","reportError","map","type","indexOf","Array","isArray"],"sources":["C:/Users/jleig/Desktop/challenges/dream-small/client/node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs"],"sourcesContent":["import didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isTypeDefinitionNode, isTypeSystemDefinitionNode, isTypeSystemExtensionNode } from \"../../language/predicates.mjs\";\nimport { specifiedScalarTypes } from \"../../type/scalars.mjs\";\nimport { introspectionTypes } from \"../../type/introspection.mjs\";\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n */\nexport function KnownTypeNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));\n  return {\n    NamedType: function NamedType(node, _1, parent, _2, ancestors) {\n      var typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;\n        var isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && isStandardTypeName(typeName)) {\n          return;\n        }\n\n        var suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);\n        context.reportError(new GraphQLError(\"Unknown type \\\"\".concat(typeName, \"\\\".\") + didYouMean(suggestedTypes), node));\n      }\n    }\n  };\n}\nvar standardTypeNames = [].concat(specifiedScalarTypes, introspectionTypes).map(function (type) {\n  return type.name;\n});\n\nfunction isStandardTypeName(typeName) {\n  return standardTypeNames.indexOf(typeName) !== -1;\n}\n\nfunction isSDLNode(value) {\n  return !Array.isArray(value) && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}