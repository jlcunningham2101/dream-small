{"ast":null,"code":"import { isNode } from '../language/ast.mjs';\nimport { Kind } from '../language/kinds.mjs';\nimport { getEnterLeaveForKind } from '../language/visitor.mjs';\nimport { getNamedType, getNullableType, isCompositeType, isEnumType, isInputObjectType, isInputType, isInterfaceType, isListType, isObjectType, isOutputType } from '../type/definition.mjs';\nimport { SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef } from '../type/introspection.mjs';\nimport { typeFromAST } from './typeFromAST.mjs';\n/**\r\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\r\n * of the current field and type definitions at any point in a GraphQL document\r\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\r\n */\n\nexport class TypeInfo {\n  constructor(schema,\n  /**\r\n   * Initial type may be provided in rare cases to facilitate traversals\r\n   *  beginning somewhere other than documents.\r\n   */\n  initialType,\n  /** @deprecated will be removed in 17.0.0 */\n  getFieldDefFn) {\n    this._schema = schema;\n    this._typeStack = [];\n    this._parentTypeStack = [];\n    this._inputTypeStack = [];\n    this._fieldDefStack = [];\n    this._defaultValueStack = [];\n    this._directive = null;\n    this._argument = null;\n    this._enumValue = null;\n    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;\n\n    if (initialType) {\n      if (isInputType(initialType)) {\n        this._inputTypeStack.push(initialType);\n      }\n\n      if (isCompositeType(initialType)) {\n        this._parentTypeStack.push(initialType);\n      }\n\n      if (isOutputType(initialType)) {\n        this._typeStack.push(initialType);\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'TypeInfo';\n  }\n\n  getType() {\n    if (this._typeStack.length > 0) {\n      return this._typeStack[this._typeStack.length - 1];\n    }\n  }\n\n  getParentType() {\n    if (this._parentTypeStack.length > 0) {\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\n    }\n  }\n\n  getInputType() {\n    if (this._inputTypeStack.length > 0) {\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\n    }\n  }\n\n  getParentInputType() {\n    if (this._inputTypeStack.length > 1) {\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\n    }\n  }\n\n  getFieldDef() {\n    if (this._fieldDefStack.length > 0) {\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\n    }\n  }\n\n  getDefaultValue() {\n    if (this._defaultValueStack.length > 0) {\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\n    }\n  }\n\n  getDirective() {\n    return this._directive;\n  }\n\n  getArgument() {\n    return this._argument;\n  }\n\n  getEnumValue() {\n    return this._enumValue;\n  }\n\n  enter(node) {\n    const schema = this._schema; // Note: many of the types below are explicitly typed as \"unknown\" to drop\n    // any assumptions of a valid schema to ensure runtime types are properly\n    // checked before continuing since TypeInfo is used as part of validation\n    // which occurs before guarantees of schema and document validity.\n\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        {\n          const namedType = getNamedType(this.getType());\n\n          this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);\n\n          break;\n        }\n\n      case Kind.FIELD:\n        {\n          const parentType = this.getParentType();\n          let fieldDef;\n          let fieldType;\n\n          if (parentType) {\n            fieldDef = this._getFieldDef(schema, parentType, node);\n\n            if (fieldDef) {\n              fieldType = fieldDef.type;\n            }\n          }\n\n          this._fieldDefStack.push(fieldDef);\n\n          this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);\n\n          break;\n        }\n\n      case Kind.DIRECTIVE:\n        this._directive = schema.getDirective(node.name.value);\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n        {\n          const rootType = schema.getRootType(node.operation);\n\n          this._typeStack.push(isObjectType(rootType) ? rootType : undefined);\n\n          break;\n        }\n\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        {\n          const typeConditionAST = node.typeCondition;\n          const outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());\n\n          this._typeStack.push(isOutputType(outputType) ? outputType : undefined);\n\n          break;\n        }\n\n      case Kind.VARIABLE_DEFINITION:\n        {\n          const inputType = typeFromAST(schema, node.type);\n\n          this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);\n\n          break;\n        }\n\n      case Kind.ARGUMENT:\n        {\n          var _this$getDirective;\n\n          let argDef;\n          let argType;\n          const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();\n\n          if (fieldOrDirective) {\n            argDef = fieldOrDirective.args.find(arg => arg.name === node.name.value);\n\n            if (argDef) {\n              argType = argDef.type;\n            }\n          }\n\n          this._argument = argDef;\n\n          this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\n\n          this._inputTypeStack.push(isInputType(argType) ? argType : undefined);\n\n          break;\n        }\n\n      case Kind.LIST:\n        {\n          const listType = getNullableType(this.getInputType());\n          const itemType = isListType(listType) ? listType.ofType : listType; // List positions never have a default value.\n\n          this._defaultValueStack.push(undefined);\n\n          this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);\n\n          break;\n        }\n\n      case Kind.OBJECT_FIELD:\n        {\n          const objectType = getNamedType(this.getInputType());\n          let inputFieldType;\n          let inputField;\n\n          if (isInputObjectType(objectType)) {\n            inputField = objectType.getFields()[node.name.value];\n\n            if (inputField) {\n              inputFieldType = inputField.type;\n            }\n          }\n\n          this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);\n\n          this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);\n\n          break;\n        }\n\n      case Kind.ENUM:\n        {\n          const enumType = getNamedType(this.getInputType());\n          let enumValue;\n\n          if (isEnumType(enumType)) {\n            enumValue = enumType.getValue(node.value);\n          }\n\n          this._enumValue = enumValue;\n          break;\n        }\n\n      default: // Ignore other nodes\n\n    }\n  }\n\n  leave(node) {\n    switch (node.kind) {\n      case Kind.SELECTION_SET:\n        this._parentTypeStack.pop();\n\n        break;\n\n      case Kind.FIELD:\n        this._fieldDefStack.pop();\n\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.DIRECTIVE:\n        this._directive = null;\n        break;\n\n      case Kind.OPERATION_DEFINITION:\n      case Kind.INLINE_FRAGMENT:\n      case Kind.FRAGMENT_DEFINITION:\n        this._typeStack.pop();\n\n        break;\n\n      case Kind.VARIABLE_DEFINITION:\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ARGUMENT:\n        this._argument = null;\n\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.LIST:\n      case Kind.OBJECT_FIELD:\n        this._defaultValueStack.pop();\n\n        this._inputTypeStack.pop();\n\n        break;\n\n      case Kind.ENUM:\n        this._enumValue = null;\n        break;\n\n      default: // Ignore other nodes\n\n    }\n  }\n\n}\n/**\r\n * Not exactly the same as the executor's definition of getFieldDef, in this\r\n * statically evaluated environment we do not always have an Object type,\r\n * and need to handle Interface and Union types.\r\n */\n\nfunction getFieldDef(schema, parentType, fieldNode) {\n  const name = fieldNode.name.value;\n\n  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  }\n\n  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  }\n\n  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\n    return TypeNameMetaFieldDef;\n  }\n\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\n    return parentType.getFields()[name];\n  }\n}\n/**\r\n * Creates a new visitor instance which maintains a provided TypeInfo instance\r\n * along with visiting visitor.\r\n */\n\n\nexport function visitWithTypeInfo(typeInfo, visitor) {\n  return {\n    enter() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      const node = args[0];\n      typeInfo.enter(node);\n      const fn = getEnterLeaveForKind(visitor, node.kind).enter;\n\n      if (fn) {\n        const result = fn.apply(visitor, args);\n\n        if (result !== undefined) {\n          typeInfo.leave(node);\n\n          if (isNode(result)) {\n            typeInfo.enter(result);\n          }\n        }\n\n        return result;\n      }\n    },\n\n    leave() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      const node = args[0];\n      const fn = getEnterLeaveForKind(visitor, node.kind).leave;\n      let result;\n\n      if (fn) {\n        result = fn.apply(visitor, args);\n      }\n\n      typeInfo.leave(node);\n      return result;\n    }\n\n  };\n}","map":{"version":3,"names":["isNode","Kind","getEnterLeaveForKind","getNamedType","getNullableType","isCompositeType","isEnumType","isInputObjectType","isInputType","isInterfaceType","isListType","isObjectType","isOutputType","SchemaMetaFieldDef","TypeMetaFieldDef","TypeNameMetaFieldDef","typeFromAST","TypeInfo","constructor","schema","initialType","getFieldDefFn","_schema","_typeStack","_parentTypeStack","_inputTypeStack","_fieldDefStack","_defaultValueStack","_directive","_argument","_enumValue","_getFieldDef","getFieldDef","push","Symbol","toStringTag","getType","length","getParentType","getInputType","getParentInputType","getDefaultValue","getDirective","getArgument","getEnumValue","enter","node","kind","SELECTION_SET","namedType","undefined","FIELD","parentType","fieldDef","fieldType","type","DIRECTIVE","name","value","OPERATION_DEFINITION","rootType","getRootType","operation","INLINE_FRAGMENT","FRAGMENT_DEFINITION","typeConditionAST","typeCondition","outputType","VARIABLE_DEFINITION","inputType","ARGUMENT","_this$getDirective","argDef","argType","fieldOrDirective","args","find","arg","defaultValue","LIST","listType","itemType","ofType","OBJECT_FIELD","objectType","inputFieldType","inputField","getFields","ENUM","enumType","enumValue","getValue","leave","pop","fieldNode","getQueryType","visitWithTypeInfo","typeInfo","visitor","fn","result","apply"],"sources":["C:/Users/Dani/Desktop/projects/dream-small/dream-small/node_modules/graphql/utilities/TypeInfo.mjs"],"sourcesContent":["import { isNode } from '../language/ast.mjs';\r\nimport { Kind } from '../language/kinds.mjs';\r\nimport { getEnterLeaveForKind } from '../language/visitor.mjs';\r\nimport {\r\n  getNamedType,\r\n  getNullableType,\r\n  isCompositeType,\r\n  isEnumType,\r\n  isInputObjectType,\r\n  isInputType,\r\n  isInterfaceType,\r\n  isListType,\r\n  isObjectType,\r\n  isOutputType,\r\n} from '../type/definition.mjs';\r\nimport {\r\n  SchemaMetaFieldDef,\r\n  TypeMetaFieldDef,\r\n  TypeNameMetaFieldDef,\r\n} from '../type/introspection.mjs';\r\nimport { typeFromAST } from './typeFromAST.mjs';\r\n/**\r\n * TypeInfo is a utility class which, given a GraphQL schema, can keep track\r\n * of the current field and type definitions at any point in a GraphQL document\r\n * AST during a recursive descent by calling `enter(node)` and `leave(node)`.\r\n */\r\n\r\nexport class TypeInfo {\r\n  constructor(\r\n    schema,\r\n    /**\r\n     * Initial type may be provided in rare cases to facilitate traversals\r\n     *  beginning somewhere other than documents.\r\n     */\r\n    initialType,\r\n    /** @deprecated will be removed in 17.0.0 */\r\n    getFieldDefFn,\r\n  ) {\r\n    this._schema = schema;\r\n    this._typeStack = [];\r\n    this._parentTypeStack = [];\r\n    this._inputTypeStack = [];\r\n    this._fieldDefStack = [];\r\n    this._defaultValueStack = [];\r\n    this._directive = null;\r\n    this._argument = null;\r\n    this._enumValue = null;\r\n    this._getFieldDef =\r\n      getFieldDefFn !== null && getFieldDefFn !== void 0\r\n        ? getFieldDefFn\r\n        : getFieldDef;\r\n\r\n    if (initialType) {\r\n      if (isInputType(initialType)) {\r\n        this._inputTypeStack.push(initialType);\r\n      }\r\n\r\n      if (isCompositeType(initialType)) {\r\n        this._parentTypeStack.push(initialType);\r\n      }\r\n\r\n      if (isOutputType(initialType)) {\r\n        this._typeStack.push(initialType);\r\n      }\r\n    }\r\n  }\r\n\r\n  get [Symbol.toStringTag]() {\r\n    return 'TypeInfo';\r\n  }\r\n\r\n  getType() {\r\n    if (this._typeStack.length > 0) {\r\n      return this._typeStack[this._typeStack.length - 1];\r\n    }\r\n  }\r\n\r\n  getParentType() {\r\n    if (this._parentTypeStack.length > 0) {\r\n      return this._parentTypeStack[this._parentTypeStack.length - 1];\r\n    }\r\n  }\r\n\r\n  getInputType() {\r\n    if (this._inputTypeStack.length > 0) {\r\n      return this._inputTypeStack[this._inputTypeStack.length - 1];\r\n    }\r\n  }\r\n\r\n  getParentInputType() {\r\n    if (this._inputTypeStack.length > 1) {\r\n      return this._inputTypeStack[this._inputTypeStack.length - 2];\r\n    }\r\n  }\r\n\r\n  getFieldDef() {\r\n    if (this._fieldDefStack.length > 0) {\r\n      return this._fieldDefStack[this._fieldDefStack.length - 1];\r\n    }\r\n  }\r\n\r\n  getDefaultValue() {\r\n    if (this._defaultValueStack.length > 0) {\r\n      return this._defaultValueStack[this._defaultValueStack.length - 1];\r\n    }\r\n  }\r\n\r\n  getDirective() {\r\n    return this._directive;\r\n  }\r\n\r\n  getArgument() {\r\n    return this._argument;\r\n  }\r\n\r\n  getEnumValue() {\r\n    return this._enumValue;\r\n  }\r\n\r\n  enter(node) {\r\n    const schema = this._schema; // Note: many of the types below are explicitly typed as \"unknown\" to drop\r\n    // any assumptions of a valid schema to ensure runtime types are properly\r\n    // checked before continuing since TypeInfo is used as part of validation\r\n    // which occurs before guarantees of schema and document validity.\r\n\r\n    switch (node.kind) {\r\n      case Kind.SELECTION_SET: {\r\n        const namedType = getNamedType(this.getType());\r\n\r\n        this._parentTypeStack.push(\r\n          isCompositeType(namedType) ? namedType : undefined,\r\n        );\r\n\r\n        break;\r\n      }\r\n\r\n      case Kind.FIELD: {\r\n        const parentType = this.getParentType();\r\n        let fieldDef;\r\n        let fieldType;\r\n\r\n        if (parentType) {\r\n          fieldDef = this._getFieldDef(schema, parentType, node);\r\n\r\n          if (fieldDef) {\r\n            fieldType = fieldDef.type;\r\n          }\r\n        }\r\n\r\n        this._fieldDefStack.push(fieldDef);\r\n\r\n        this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);\r\n\r\n        break;\r\n      }\r\n\r\n      case Kind.DIRECTIVE:\r\n        this._directive = schema.getDirective(node.name.value);\r\n        break;\r\n\r\n      case Kind.OPERATION_DEFINITION: {\r\n        const rootType = schema.getRootType(node.operation);\r\n\r\n        this._typeStack.push(isObjectType(rootType) ? rootType : undefined);\r\n\r\n        break;\r\n      }\r\n\r\n      case Kind.INLINE_FRAGMENT:\r\n      case Kind.FRAGMENT_DEFINITION: {\r\n        const typeConditionAST = node.typeCondition;\r\n        const outputType = typeConditionAST\r\n          ? typeFromAST(schema, typeConditionAST)\r\n          : getNamedType(this.getType());\r\n\r\n        this._typeStack.push(isOutputType(outputType) ? outputType : undefined);\r\n\r\n        break;\r\n      }\r\n\r\n      case Kind.VARIABLE_DEFINITION: {\r\n        const inputType = typeFromAST(schema, node.type);\r\n\r\n        this._inputTypeStack.push(\r\n          isInputType(inputType) ? inputType : undefined,\r\n        );\r\n\r\n        break;\r\n      }\r\n\r\n      case Kind.ARGUMENT: {\r\n        var _this$getDirective;\r\n\r\n        let argDef;\r\n        let argType;\r\n        const fieldOrDirective =\r\n          (_this$getDirective = this.getDirective()) !== null &&\r\n          _this$getDirective !== void 0\r\n            ? _this$getDirective\r\n            : this.getFieldDef();\r\n\r\n        if (fieldOrDirective) {\r\n          argDef = fieldOrDirective.args.find(\r\n            (arg) => arg.name === node.name.value,\r\n          );\r\n\r\n          if (argDef) {\r\n            argType = argDef.type;\r\n          }\r\n        }\r\n\r\n        this._argument = argDef;\r\n\r\n        this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);\r\n\r\n        this._inputTypeStack.push(isInputType(argType) ? argType : undefined);\r\n\r\n        break;\r\n      }\r\n\r\n      case Kind.LIST: {\r\n        const listType = getNullableType(this.getInputType());\r\n        const itemType = isListType(listType) ? listType.ofType : listType; // List positions never have a default value.\r\n\r\n        this._defaultValueStack.push(undefined);\r\n\r\n        this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);\r\n\r\n        break;\r\n      }\r\n\r\n      case Kind.OBJECT_FIELD: {\r\n        const objectType = getNamedType(this.getInputType());\r\n        let inputFieldType;\r\n        let inputField;\r\n\r\n        if (isInputObjectType(objectType)) {\r\n          inputField = objectType.getFields()[node.name.value];\r\n\r\n          if (inputField) {\r\n            inputFieldType = inputField.type;\r\n          }\r\n        }\r\n\r\n        this._defaultValueStack.push(\r\n          inputField ? inputField.defaultValue : undefined,\r\n        );\r\n\r\n        this._inputTypeStack.push(\r\n          isInputType(inputFieldType) ? inputFieldType : undefined,\r\n        );\r\n\r\n        break;\r\n      }\r\n\r\n      case Kind.ENUM: {\r\n        const enumType = getNamedType(this.getInputType());\r\n        let enumValue;\r\n\r\n        if (isEnumType(enumType)) {\r\n          enumValue = enumType.getValue(node.value);\r\n        }\r\n\r\n        this._enumValue = enumValue;\r\n        break;\r\n      }\r\n\r\n      default: // Ignore other nodes\r\n    }\r\n  }\r\n\r\n  leave(node) {\r\n    switch (node.kind) {\r\n      case Kind.SELECTION_SET:\r\n        this._parentTypeStack.pop();\r\n\r\n        break;\r\n\r\n      case Kind.FIELD:\r\n        this._fieldDefStack.pop();\r\n\r\n        this._typeStack.pop();\r\n\r\n        break;\r\n\r\n      case Kind.DIRECTIVE:\r\n        this._directive = null;\r\n        break;\r\n\r\n      case Kind.OPERATION_DEFINITION:\r\n      case Kind.INLINE_FRAGMENT:\r\n      case Kind.FRAGMENT_DEFINITION:\r\n        this._typeStack.pop();\r\n\r\n        break;\r\n\r\n      case Kind.VARIABLE_DEFINITION:\r\n        this._inputTypeStack.pop();\r\n\r\n        break;\r\n\r\n      case Kind.ARGUMENT:\r\n        this._argument = null;\r\n\r\n        this._defaultValueStack.pop();\r\n\r\n        this._inputTypeStack.pop();\r\n\r\n        break;\r\n\r\n      case Kind.LIST:\r\n      case Kind.OBJECT_FIELD:\r\n        this._defaultValueStack.pop();\r\n\r\n        this._inputTypeStack.pop();\r\n\r\n        break;\r\n\r\n      case Kind.ENUM:\r\n        this._enumValue = null;\r\n        break;\r\n\r\n      default: // Ignore other nodes\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Not exactly the same as the executor's definition of getFieldDef, in this\r\n * statically evaluated environment we do not always have an Object type,\r\n * and need to handle Interface and Union types.\r\n */\r\nfunction getFieldDef(schema, parentType, fieldNode) {\r\n  const name = fieldNode.name.value;\r\n\r\n  if (\r\n    name === SchemaMetaFieldDef.name &&\r\n    schema.getQueryType() === parentType\r\n  ) {\r\n    return SchemaMetaFieldDef;\r\n  }\r\n\r\n  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {\r\n    return TypeMetaFieldDef;\r\n  }\r\n\r\n  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {\r\n    return TypeNameMetaFieldDef;\r\n  }\r\n\r\n  if (isObjectType(parentType) || isInterfaceType(parentType)) {\r\n    return parentType.getFields()[name];\r\n  }\r\n}\r\n/**\r\n * Creates a new visitor instance which maintains a provided TypeInfo instance\r\n * along with visiting visitor.\r\n */\r\n\r\nexport function visitWithTypeInfo(typeInfo, visitor) {\r\n  return {\r\n    enter(...args) {\r\n      const node = args[0];\r\n      typeInfo.enter(node);\r\n      const fn = getEnterLeaveForKind(visitor, node.kind).enter;\r\n\r\n      if (fn) {\r\n        const result = fn.apply(visitor, args);\r\n\r\n        if (result !== undefined) {\r\n          typeInfo.leave(node);\r\n\r\n          if (isNode(result)) {\r\n            typeInfo.enter(result);\r\n          }\r\n        }\r\n\r\n        return result;\r\n      }\r\n    },\r\n\r\n    leave(...args) {\r\n      const node = args[0];\r\n      const fn = getEnterLeaveForKind(visitor, node.kind).leave;\r\n      let result;\r\n\r\n      if (fn) {\r\n        result = fn.apply(visitor, args);\r\n      }\r\n\r\n      typeInfo.leave(node);\r\n      return result;\r\n    },\r\n  };\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}