{"ast":null,"code":"import arrayFrom from \"../../polyfills/arrayFrom.mjs\";\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport naturalCompare from \"../../jsutils/naturalCompare.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isObjectType, isInterfaceType, isAbstractType } from \"../../type/definition.mjs\";\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\n\nexport function FieldsOnCorrectTypeRule(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n\n      if (type) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestion = didYouMean('to use an inline fragment on', getSuggestedTypeNames(schema, type, fieldName)); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n\n          context.reportError(new GraphQLError(\"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type.name, \"\\\".\") + suggestion, node));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!isAbstractType(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  var suggestedTypes = new Set();\n  var usageCount = Object.create(null);\n\n  for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++) {\n    var possibleType = _schema$getPossibleTy2[_i2];\n\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {\n      var _usageCount$possibleI;\n\n      var possibleInterface = _possibleType$getInte2[_i4];\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;\n    }\n  }\n\n  return arrayFrom(suggestedTypes).sort(function (typeA, typeB) {\n    // Suggest both interface and object types based on how common they are.\n    var usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n    if (usageCountDiff !== 0) {\n      return usageCountDiff;\n    } // Suggest super types first followed by subtypes\n\n\n    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n      return -1;\n    }\n\n    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n      return 1;\n    }\n\n    return naturalCompare(typeA.name, typeB.name);\n  }).map(function (x) {\n    return x.name;\n  });\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}","map":{"version":3,"names":["arrayFrom","didYouMean","suggestionList","naturalCompare","GraphQLError","isObjectType","isInterfaceType","isAbstractType","FieldsOnCorrectTypeRule","context","Field","node","type","getParentType","fieldDef","getFieldDef","schema","getSchema","fieldName","name","value","suggestion","getSuggestedTypeNames","getSuggestedFieldNames","reportError","concat","suggestedTypes","Set","usageCount","Object","create","_i2","_schema$getPossibleTy2","getPossibleTypes","length","possibleType","getFields","add","_i4","_possibleType$getInte2","getInterfaces","_usageCount$possibleI","possibleInterface","sort","typeA","typeB","usageCountDiff","isSubType","map","x","possibleFieldNames","keys"],"sources":["C:/Users/jleig/Desktop/challenges/dream-small/client/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs"],"sourcesContent":["import arrayFrom from \"../../polyfills/arrayFrom.mjs\";\nimport didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport naturalCompare from \"../../jsutils/naturalCompare.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isObjectType, isInterfaceType, isAbstractType } from \"../../type/definition.mjs\";\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n */\nexport function FieldsOnCorrectTypeRule(context) {\n  return {\n    Field: function Field(node) {\n      var type = context.getParentType();\n\n      if (type) {\n        var fieldDef = context.getFieldDef();\n\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          var schema = context.getSchema();\n          var fieldName = node.name.value; // First determine if there are any suggested types to condition on.\n\n          var suggestion = didYouMean('to use an inline fragment on', getSuggestedTypeNames(schema, type, fieldName)); // If there are no suggested types, then perhaps this was a typo?\n\n          if (suggestion === '') {\n            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));\n          } // Report an error, including helpful suggestions.\n\n\n          context.reportError(new GraphQLError(\"Cannot query field \\\"\".concat(fieldName, \"\\\" on type \\\"\").concat(type.name, \"\\\".\") + suggestion, node));\n        }\n      }\n    }\n  };\n}\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\n\nfunction getSuggestedTypeNames(schema, type, fieldName) {\n  if (!isAbstractType(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  var suggestedTypes = new Set();\n  var usageCount = Object.create(null);\n\n  for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type); _i2 < _schema$getPossibleTy2.length; _i2++) {\n    var possibleType = _schema$getPossibleTy2[_i2];\n\n    if (!possibleType.getFields()[fieldName]) {\n      continue;\n    } // This object type defines this field.\n\n\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {\n      var _usageCount$possibleI;\n\n      var possibleInterface = _possibleType$getInte2[_i4];\n\n      if (!possibleInterface.getFields()[fieldName]) {\n        continue;\n      } // This interface type defines this field.\n\n\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;\n    }\n  }\n\n  return arrayFrom(suggestedTypes).sort(function (typeA, typeB) {\n    // Suggest both interface and object types based on how common they are.\n    var usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n\n    if (usageCountDiff !== 0) {\n      return usageCountDiff;\n    } // Suggest super types first followed by subtypes\n\n\n    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n      return -1;\n    }\n\n    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n      return 1;\n    }\n\n    return naturalCompare(typeA.name, typeB.name);\n  }).map(function (x) {\n    return x.name;\n  });\n}\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\n\n\nfunction getSuggestedFieldNames(type, fieldName) {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    var possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  } // Otherwise, must be a Union type, which does not define fields.\n\n\n  return [];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}