{"ast":null,"code":"import { inspect } from '../../jsutils/inspect.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { print } from '../../language/printer.mjs';\nimport { getNamedType, isInterfaceType, isLeafType, isListType, isNonNullType, isObjectType } from '../../type/definition.mjs';\nimport { sortValueNode } from '../../utilities/sortValueNode.mjs';\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\n\nfunction reasonMessage(reason) {\n  if (Array.isArray(reason)) {\n    return reason.map(_ref => {\n      let [responseName, subReason] = _ref;\n      return `subfields \"${responseName}\" conflict because ` + reasonMessage(subReason);\n    }).join(' and ');\n  }\n\n  return reason;\n}\n/**\r\n * Overlapping fields can be merged\r\n *\r\n * A selection set is only valid if all fields (including spreading any\r\n * fragments) either correspond to distinct response names or can be merged\r\n * without ambiguity.\r\n *\r\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\r\n */\n\n\nexport function OverlappingFieldsCanBeMergedRule(context) {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  const comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n\n  const cachedFieldsAndFragmentNames = new Map();\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);\n\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\n        const reasonMsg = reasonMessage(reason);\n        context.reportError(new GraphQLError(`Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`, {\n          nodes: fields1.concat(fields2)\n        }));\n      }\n    }\n\n  };\n}\n/**\r\n * Algorithm:\r\n *\r\n * Conflicts occur when two fields exist in a query which will produce the same\r\n * response name, but represent differing values, thus creating a conflict.\r\n * The algorithm below finds all conflicts via making a series of comparisons\r\n * between fields. In order to compare as few fields as possible, this makes\r\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\r\n *\r\n * Given any selection set, a collection produces both a set of fields by\r\n * also including all inline fragments, as well as a list of fragments\r\n * referenced by fragment spreads.\r\n *\r\n * A) Each selection set represented in the document first compares \"within\" its\r\n * collected set of fields, finding any conflicts between every pair of\r\n * overlapping fields.\r\n * Note: This is the *only time* that a the fields \"within\" a set are compared\r\n * to each other. After this only fields \"between\" sets are compared.\r\n *\r\n * B) Also, if any fragment is referenced in a selection set, then a\r\n * comparison is made \"between\" the original set of fields and the\r\n * referenced fragment.\r\n *\r\n * C) Also, if multiple fragments are referenced, then comparisons\r\n * are made \"between\" each referenced fragment.\r\n *\r\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\r\n * a comparison is made between each field in the original set of fields and\r\n * each field in the the referenced set of fields.\r\n *\r\n * E) Also, if any fragment is referenced in the referenced selection set,\r\n * then a comparison is made \"between\" the original set of fields and the\r\n * referenced fragment (recursively referring to step D).\r\n *\r\n * F) When comparing \"between\" two fragments, first a comparison is made between\r\n * each field in the first referenced set of fields and each field in the the\r\n * second referenced set of fields.\r\n *\r\n * G) Also, any fragments referenced by the first must be compared to the\r\n * second, and any fragments referenced by the second must be compared to the\r\n * first (recursively referring to step F).\r\n *\r\n * H) When comparing two fields, if both have selection sets, then a comparison\r\n * is made \"between\" both selection sets, first comparing the set of fields in\r\n * the first selection set with the set of fields in the second.\r\n *\r\n * I) Also, if any fragment is referenced in either selection set, then a\r\n * comparison is made \"between\" the other set of fields and the\r\n * referenced fragment.\r\n *\r\n * J) Also, if two fragments are referenced in both selection sets, then a\r\n * comparison is made \"between\" the two fragments.\r\n *\r\n */\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\n\nfunction findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {\n  const conflicts = [];\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet); // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n\n  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);\n\n  if (fragmentNames.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread fragment name found.\n    for (let i = 0; i < fragmentNames.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]); // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment names to every other\n      // item in that same list (except for itself).\n\n      for (let j = i + 1; j < fragmentNames.length; j++) {\n        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);\n      }\n    }\n  }\n\n  return conflicts;\n} // Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\n\n\nfunction collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {\n  const fragment = context.getFragment(fragmentName);\n\n  if (!fragment) {\n    return;\n  }\n\n  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment); // Do not compare a fragment's fieldMap to itself.\n\n  if (fieldMap === fieldMap2) {\n    return;\n  } // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2); // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n\n  for (const referencedFragmentName of referencedFragmentNames) {\n    // Memoize so two fragments are not compared for conflicts more than once.\n    if (comparedFragmentPairs.has(referencedFragmentName, fragmentName, areMutuallyExclusive)) {\n      continue;\n    }\n\n    comparedFragmentPairs.add(referencedFragmentName, fragmentName, areMutuallyExclusive);\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);\n  }\n} // Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\n\n\nfunction collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {\n  // No need to compare a fragment to itself.\n  if (fragmentName1 === fragmentName2) {\n    return;\n  } // Memoize so two fragments are not compared for conflicts more than once.\n\n\n  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {\n    return;\n  }\n\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n  const fragment1 = context.getFragment(fragmentName1);\n  const fragment2 = context.getFragment(fragmentName2);\n\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1);\n  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2); // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);\n  } // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n\n\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\n    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);\n  }\n} // Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\n\n\nfunction findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {\n  const conflicts = [];\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1);\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2); // (H) First, collect all conflicts between these two collections of field.\n\n  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2); // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n\n  for (const fragmentName2 of fragmentNames2) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);\n  } // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n\n\n  for (const fragmentName1 of fragmentNames1) {\n    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);\n  } // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n\n\n  for (const fragmentName1 of fragmentNames1) {\n    for (const fragmentName2 of fragmentNames2) {\n      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2);\n    }\n  }\n\n  return conflicts;\n} // Collect all Conflicts \"within\" one collection of fields.\n\n\nfunction collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, // within one collection is never mutually exclusive\n          responseName, fields[i], fields[j]);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\n\n\nfunction collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\n    const fields2 = fieldMap2[responseName];\n\n    if (fields2) {\n      for (const field1 of fields1) {\n        for (const field2 of fields2) {\n          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);\n\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n} // Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\n\n\nfunction findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {\n  const [parentType1, node1, def1] = field1;\n  const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n\n  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    const name1 = node1.name.value;\n    const name2 = node2.name.value;\n\n    if (name1 !== name2) {\n      return [[responseName, `\"${name1}\" and \"${name2}\" are different fields`], [node1], [node2]];\n    } // Two field calls must have the same arguments.\n\n\n    if (stringifyArguments(node1) !== stringifyArguments(node2)) {\n      return [[responseName, 'they have differing arguments'], [node1], [node2]];\n    }\n  } // The return type for each field.\n\n\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [[responseName, `they return conflicting types \"${inspect(type1)}\" and \"${inspect(type2)}\"`], [node1], [node2]];\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n\n\n  const selectionSet1 = node1.selectionSet;\n  const selectionSet2 = node2.selectionSet;\n\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction stringifyArguments(fieldNode) {\n  var _fieldNode$arguments; // FIXME https://github.com/graphql/graphql-js/issues/2203\n\n\n  const args =\n  /* c8 ignore next */\n  (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];\n  const inputObjectWithArgs = {\n    kind: Kind.OBJECT,\n    fields: args.map(argNode => ({\n      kind: Kind.OBJECT_FIELD,\n      name: argNode.name,\n      value: argNode.value\n    }))\n  };\n  return print(sortValueNode(inputObjectWithArgs));\n} // Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\n\n\nfunction doTypesConflict(type1, type2) {\n  if (isListType(type1)) {\n    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isListType(type2)) {\n    return true;\n  }\n\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;\n  }\n\n  if (isNonNullType(type2)) {\n    return true;\n  }\n\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n\n  return false;\n} // Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\n\n\nfunction getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const nodeAndDefs = Object.create(null);\n  const fragmentNames = Object.create(null);\n\n  _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);\n\n  const result = [nodeAndDefs, Object.keys(fragmentNames)];\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\n  return result;\n} // Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\n\n\nfunction getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {\n  // Short-circuit building a type from the node if possible.\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n\n  if (cached) {\n    return cached;\n  }\n\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);\n}\n\nfunction _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD:\n        {\n          const fieldName = selection.name.value;\n          let fieldDef;\n\n          if (isObjectType(parentType) || isInterfaceType(parentType)) {\n            fieldDef = parentType.getFields()[fieldName];\n          }\n\n          const responseName = selection.alias ? selection.alias.value : fieldName;\n\n          if (!nodeAndDefs[responseName]) {\n            nodeAndDefs[responseName] = [];\n          }\n\n          nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\n          break;\n        }\n\n      case Kind.FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n\n      case Kind.INLINE_FRAGMENT:\n        {\n          const typeCondition = selection.typeCondition;\n          const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;\n\n          _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);\n\n          break;\n        }\n    }\n  }\n} // Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\n\n\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\n  if (conflicts.length > 0) {\n    return [[responseName, conflicts.map(_ref2 => {\n      let [reason] = _ref2;\n      return reason;\n    })], [node1, ...conflicts.map(_ref3 => {\n      let [, fields1] = _ref3;\n      return fields1;\n    }).flat()], [node2, ...conflicts.map(_ref4 => {\n      let [,, fields2] = _ref4;\n      return fields2;\n    }).flat()]];\n  }\n}\n/**\r\n * A way to keep track of pairs of things when the ordering of the pair does not matter.\r\n */\n\n\nclass PairSet {\n  constructor() {\n    this._data = new Map();\n  }\n\n  has(a, b, areMutuallyExclusive) {\n    var _this$_data$get;\n\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n    const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);\n\n    if (result === undefined) {\n      return false;\n    } // areMutuallyExclusive being false is a superset of being true, hence if\n    // we want to know if this PairSet \"has\" these two with no exclusivity,\n    // we have to ensure it was added as such.\n\n\n    return areMutuallyExclusive ? true : areMutuallyExclusive === result;\n  }\n\n  add(a, b, areMutuallyExclusive) {\n    const [key1, key2] = a < b ? [a, b] : [b, a];\n\n    const map = this._data.get(key1);\n\n    if (map === undefined) {\n      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));\n    } else {\n      map.set(key2, areMutuallyExclusive);\n    }\n  }\n\n}","map":{"version":3,"names":["inspect","GraphQLError","Kind","print","getNamedType","isInterfaceType","isLeafType","isListType","isNonNullType","isObjectType","sortValueNode","typeFromAST","reasonMessage","reason","Array","isArray","map","responseName","subReason","join","OverlappingFieldsCanBeMergedRule","context","comparedFragmentPairs","PairSet","cachedFieldsAndFragmentNames","Map","SelectionSet","selectionSet","conflicts","findConflictsWithinSelectionSet","getParentType","fields1","fields2","reasonMsg","reportError","nodes","concat","parentType","fieldMap","fragmentNames","getFieldsAndFragmentNames","collectConflictsWithin","length","i","collectConflictsBetweenFieldsAndFragment","j","collectConflictsBetweenFragments","areMutuallyExclusive","fragmentName","fragment","getFragment","fieldMap2","referencedFragmentNames","getReferencedFieldsAndFragmentNames","collectConflictsBetween","referencedFragmentName","has","add","fragmentName1","fragmentName2","fragment1","fragment2","fieldMap1","referencedFragmentNames1","referencedFragmentNames2","referencedFragmentName2","referencedFragmentName1","findConflictsBetweenSubSelectionSets","parentType1","selectionSet1","parentType2","selectionSet2","fragmentNames1","fragmentNames2","fields","Object","entries","conflict","findConflict","push","parentFieldsAreMutuallyExclusive","field1","field2","node1","def1","node2","def2","name1","name","value","name2","stringifyArguments","type1","type","type2","doTypesConflict","subfieldConflicts","fieldNode","_fieldNode$arguments","args","arguments","inputObjectWithArgs","kind","OBJECT","argNode","OBJECT_FIELD","ofType","cached","get","nodeAndDefs","create","_collectFieldsAndFragmentNames","result","keys","set","fragmentType","getSchema","typeCondition","selection","selections","FIELD","fieldName","fieldDef","getFields","alias","FRAGMENT_SPREAD","INLINE_FRAGMENT","inlineFragmentType","flat","constructor","_data","a","b","_this$_data$get","key1","key2","undefined"],"sources":["C:/Users/Dani/Desktop/projects/dream-small/dream-small/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs"],"sourcesContent":["import { inspect } from '../../jsutils/inspect.mjs';\r\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\r\nimport { Kind } from '../../language/kinds.mjs';\r\nimport { print } from '../../language/printer.mjs';\r\nimport {\r\n  getNamedType,\r\n  isInterfaceType,\r\n  isLeafType,\r\n  isListType,\r\n  isNonNullType,\r\n  isObjectType,\r\n} from '../../type/definition.mjs';\r\nimport { sortValueNode } from '../../utilities/sortValueNode.mjs';\r\nimport { typeFromAST } from '../../utilities/typeFromAST.mjs';\r\n\r\nfunction reasonMessage(reason) {\r\n  if (Array.isArray(reason)) {\r\n    return reason\r\n      .map(\r\n        ([responseName, subReason]) =>\r\n          `subfields \"${responseName}\" conflict because ` +\r\n          reasonMessage(subReason),\r\n      )\r\n      .join(' and ');\r\n  }\r\n\r\n  return reason;\r\n}\r\n/**\r\n * Overlapping fields can be merged\r\n *\r\n * A selection set is only valid if all fields (including spreading any\r\n * fragments) either correspond to distinct response names or can be merged\r\n * without ambiguity.\r\n *\r\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\r\n */\r\n\r\nexport function OverlappingFieldsCanBeMergedRule(context) {\r\n  // A memoization for when two fragments are compared \"between\" each other for\r\n  // conflicts. Two fragments may be compared many times, so memoizing this can\r\n  // dramatically improve the performance of this validator.\r\n  const comparedFragmentPairs = new PairSet(); // A cache for the \"field map\" and list of fragment names found in any given\r\n  // selection set. Selection sets may be asked for this information multiple\r\n  // times, so this improves the performance of this validator.\r\n\r\n  const cachedFieldsAndFragmentNames = new Map();\r\n  return {\r\n    SelectionSet(selectionSet) {\r\n      const conflicts = findConflictsWithinSelectionSet(\r\n        context,\r\n        cachedFieldsAndFragmentNames,\r\n        comparedFragmentPairs,\r\n        context.getParentType(),\r\n        selectionSet,\r\n      );\r\n\r\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\r\n        const reasonMsg = reasonMessage(reason);\r\n        context.reportError(\r\n          new GraphQLError(\r\n            `Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,\r\n            {\r\n              nodes: fields1.concat(fields2),\r\n            },\r\n          ),\r\n        );\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Algorithm:\r\n *\r\n * Conflicts occur when two fields exist in a query which will produce the same\r\n * response name, but represent differing values, thus creating a conflict.\r\n * The algorithm below finds all conflicts via making a series of comparisons\r\n * between fields. In order to compare as few fields as possible, this makes\r\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\r\n *\r\n * Given any selection set, a collection produces both a set of fields by\r\n * also including all inline fragments, as well as a list of fragments\r\n * referenced by fragment spreads.\r\n *\r\n * A) Each selection set represented in the document first compares \"within\" its\r\n * collected set of fields, finding any conflicts between every pair of\r\n * overlapping fields.\r\n * Note: This is the *only time* that a the fields \"within\" a set are compared\r\n * to each other. After this only fields \"between\" sets are compared.\r\n *\r\n * B) Also, if any fragment is referenced in a selection set, then a\r\n * comparison is made \"between\" the original set of fields and the\r\n * referenced fragment.\r\n *\r\n * C) Also, if multiple fragments are referenced, then comparisons\r\n * are made \"between\" each referenced fragment.\r\n *\r\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\r\n * a comparison is made between each field in the original set of fields and\r\n * each field in the the referenced set of fields.\r\n *\r\n * E) Also, if any fragment is referenced in the referenced selection set,\r\n * then a comparison is made \"between\" the original set of fields and the\r\n * referenced fragment (recursively referring to step D).\r\n *\r\n * F) When comparing \"between\" two fragments, first a comparison is made between\r\n * each field in the first referenced set of fields and each field in the the\r\n * second referenced set of fields.\r\n *\r\n * G) Also, any fragments referenced by the first must be compared to the\r\n * second, and any fragments referenced by the second must be compared to the\r\n * first (recursively referring to step F).\r\n *\r\n * H) When comparing two fields, if both have selection sets, then a comparison\r\n * is made \"between\" both selection sets, first comparing the set of fields in\r\n * the first selection set with the set of fields in the second.\r\n *\r\n * I) Also, if any fragment is referenced in either selection set, then a\r\n * comparison is made \"between\" the other set of fields and the\r\n * referenced fragment.\r\n *\r\n * J) Also, if two fragments are referenced in both selection sets, then a\r\n * comparison is made \"between\" the two fragments.\r\n *\r\n */\r\n// Find all conflicts found \"within\" a selection set, including those found\r\n// via spreading in fragments. Called when visiting each SelectionSet in the\r\n// GraphQL Document.\r\nfunction findConflictsWithinSelectionSet(\r\n  context,\r\n  cachedFieldsAndFragmentNames,\r\n  comparedFragmentPairs,\r\n  parentType,\r\n  selectionSet,\r\n) {\r\n  const conflicts = [];\r\n  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(\r\n    context,\r\n    cachedFieldsAndFragmentNames,\r\n    parentType,\r\n    selectionSet,\r\n  ); // (A) Find find all conflicts \"within\" the fields of this selection set.\r\n  // Note: this is the *only place* `collectConflictsWithin` is called.\r\n\r\n  collectConflictsWithin(\r\n    context,\r\n    conflicts,\r\n    cachedFieldsAndFragmentNames,\r\n    comparedFragmentPairs,\r\n    fieldMap,\r\n  );\r\n\r\n  if (fragmentNames.length !== 0) {\r\n    // (B) Then collect conflicts between these fields and those represented by\r\n    // each spread fragment name found.\r\n    for (let i = 0; i < fragmentNames.length; i++) {\r\n      collectConflictsBetweenFieldsAndFragment(\r\n        context,\r\n        conflicts,\r\n        cachedFieldsAndFragmentNames,\r\n        comparedFragmentPairs,\r\n        false,\r\n        fieldMap,\r\n        fragmentNames[i],\r\n      ); // (C) Then compare this fragment with all other fragments found in this\r\n      // selection set to collect conflicts between fragments spread together.\r\n      // This compares each item in the list of fragment names to every other\r\n      // item in that same list (except for itself).\r\n\r\n      for (let j = i + 1; j < fragmentNames.length; j++) {\r\n        collectConflictsBetweenFragments(\r\n          context,\r\n          conflicts,\r\n          cachedFieldsAndFragmentNames,\r\n          comparedFragmentPairs,\r\n          false,\r\n          fragmentNames[i],\r\n          fragmentNames[j],\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  return conflicts;\r\n} // Collect all conflicts found between a set of fields and a fragment reference\r\n// including via spreading in any nested fragments.\r\n\r\nfunction collectConflictsBetweenFieldsAndFragment(\r\n  context,\r\n  conflicts,\r\n  cachedFieldsAndFragmentNames,\r\n  comparedFragmentPairs,\r\n  areMutuallyExclusive,\r\n  fieldMap,\r\n  fragmentName,\r\n) {\r\n  const fragment = context.getFragment(fragmentName);\r\n\r\n  if (!fragment) {\r\n    return;\r\n  }\r\n\r\n  const [fieldMap2, referencedFragmentNames] =\r\n    getReferencedFieldsAndFragmentNames(\r\n      context,\r\n      cachedFieldsAndFragmentNames,\r\n      fragment,\r\n    ); // Do not compare a fragment's fieldMap to itself.\r\n\r\n  if (fieldMap === fieldMap2) {\r\n    return;\r\n  } // (D) First collect any conflicts between the provided collection of fields\r\n  // and the collection of fields represented by the given fragment.\r\n\r\n  collectConflictsBetween(\r\n    context,\r\n    conflicts,\r\n    cachedFieldsAndFragmentNames,\r\n    comparedFragmentPairs,\r\n    areMutuallyExclusive,\r\n    fieldMap,\r\n    fieldMap2,\r\n  ); // (E) Then collect any conflicts between the provided collection of fields\r\n  // and any fragment names found in the given fragment.\r\n\r\n  for (const referencedFragmentName of referencedFragmentNames) {\r\n    // Memoize so two fragments are not compared for conflicts more than once.\r\n    if (\r\n      comparedFragmentPairs.has(\r\n        referencedFragmentName,\r\n        fragmentName,\r\n        areMutuallyExclusive,\r\n      )\r\n    ) {\r\n      continue;\r\n    }\r\n\r\n    comparedFragmentPairs.add(\r\n      referencedFragmentName,\r\n      fragmentName,\r\n      areMutuallyExclusive,\r\n    );\r\n    collectConflictsBetweenFieldsAndFragment(\r\n      context,\r\n      conflicts,\r\n      cachedFieldsAndFragmentNames,\r\n      comparedFragmentPairs,\r\n      areMutuallyExclusive,\r\n      fieldMap,\r\n      referencedFragmentName,\r\n    );\r\n  }\r\n} // Collect all conflicts found between two fragments, including via spreading in\r\n// any nested fragments.\r\n\r\nfunction collectConflictsBetweenFragments(\r\n  context,\r\n  conflicts,\r\n  cachedFieldsAndFragmentNames,\r\n  comparedFragmentPairs,\r\n  areMutuallyExclusive,\r\n  fragmentName1,\r\n  fragmentName2,\r\n) {\r\n  // No need to compare a fragment to itself.\r\n  if (fragmentName1 === fragmentName2) {\r\n    return;\r\n  } // Memoize so two fragments are not compared for conflicts more than once.\r\n\r\n  if (\r\n    comparedFragmentPairs.has(\r\n      fragmentName1,\r\n      fragmentName2,\r\n      areMutuallyExclusive,\r\n    )\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);\r\n  const fragment1 = context.getFragment(fragmentName1);\r\n  const fragment2 = context.getFragment(fragmentName2);\r\n\r\n  if (!fragment1 || !fragment2) {\r\n    return;\r\n  }\r\n\r\n  const [fieldMap1, referencedFragmentNames1] =\r\n    getReferencedFieldsAndFragmentNames(\r\n      context,\r\n      cachedFieldsAndFragmentNames,\r\n      fragment1,\r\n    );\r\n  const [fieldMap2, referencedFragmentNames2] =\r\n    getReferencedFieldsAndFragmentNames(\r\n      context,\r\n      cachedFieldsAndFragmentNames,\r\n      fragment2,\r\n    ); // (F) First, collect all conflicts between these two collections of fields\r\n  // (not including any nested fragments).\r\n\r\n  collectConflictsBetween(\r\n    context,\r\n    conflicts,\r\n    cachedFieldsAndFragmentNames,\r\n    comparedFragmentPairs,\r\n    areMutuallyExclusive,\r\n    fieldMap1,\r\n    fieldMap2,\r\n  ); // (G) Then collect conflicts between the first fragment and any nested\r\n  // fragments spread in the second fragment.\r\n\r\n  for (const referencedFragmentName2 of referencedFragmentNames2) {\r\n    collectConflictsBetweenFragments(\r\n      context,\r\n      conflicts,\r\n      cachedFieldsAndFragmentNames,\r\n      comparedFragmentPairs,\r\n      areMutuallyExclusive,\r\n      fragmentName1,\r\n      referencedFragmentName2,\r\n    );\r\n  } // (G) Then collect conflicts between the second fragment and any nested\r\n  // fragments spread in the first fragment.\r\n\r\n  for (const referencedFragmentName1 of referencedFragmentNames1) {\r\n    collectConflictsBetweenFragments(\r\n      context,\r\n      conflicts,\r\n      cachedFieldsAndFragmentNames,\r\n      comparedFragmentPairs,\r\n      areMutuallyExclusive,\r\n      referencedFragmentName1,\r\n      fragmentName2,\r\n    );\r\n  }\r\n} // Find all conflicts found between two selection sets, including those found\r\n// via spreading in fragments. Called when determining if conflicts exist\r\n// between the sub-fields of two overlapping fields.\r\n\r\nfunction findConflictsBetweenSubSelectionSets(\r\n  context,\r\n  cachedFieldsAndFragmentNames,\r\n  comparedFragmentPairs,\r\n  areMutuallyExclusive,\r\n  parentType1,\r\n  selectionSet1,\r\n  parentType2,\r\n  selectionSet2,\r\n) {\r\n  const conflicts = [];\r\n  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(\r\n    context,\r\n    cachedFieldsAndFragmentNames,\r\n    parentType1,\r\n    selectionSet1,\r\n  );\r\n  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(\r\n    context,\r\n    cachedFieldsAndFragmentNames,\r\n    parentType2,\r\n    selectionSet2,\r\n  ); // (H) First, collect all conflicts between these two collections of field.\r\n\r\n  collectConflictsBetween(\r\n    context,\r\n    conflicts,\r\n    cachedFieldsAndFragmentNames,\r\n    comparedFragmentPairs,\r\n    areMutuallyExclusive,\r\n    fieldMap1,\r\n    fieldMap2,\r\n  ); // (I) Then collect conflicts between the first collection of fields and\r\n  // those referenced by each fragment name associated with the second.\r\n\r\n  for (const fragmentName2 of fragmentNames2) {\r\n    collectConflictsBetweenFieldsAndFragment(\r\n      context,\r\n      conflicts,\r\n      cachedFieldsAndFragmentNames,\r\n      comparedFragmentPairs,\r\n      areMutuallyExclusive,\r\n      fieldMap1,\r\n      fragmentName2,\r\n    );\r\n  } // (I) Then collect conflicts between the second collection of fields and\r\n  // those referenced by each fragment name associated with the first.\r\n\r\n  for (const fragmentName1 of fragmentNames1) {\r\n    collectConflictsBetweenFieldsAndFragment(\r\n      context,\r\n      conflicts,\r\n      cachedFieldsAndFragmentNames,\r\n      comparedFragmentPairs,\r\n      areMutuallyExclusive,\r\n      fieldMap2,\r\n      fragmentName1,\r\n    );\r\n  } // (J) Also collect conflicts between any fragment names by the first and\r\n  // fragment names by the second. This compares each item in the first set of\r\n  // names to each item in the second set of names.\r\n\r\n  for (const fragmentName1 of fragmentNames1) {\r\n    for (const fragmentName2 of fragmentNames2) {\r\n      collectConflictsBetweenFragments(\r\n        context,\r\n        conflicts,\r\n        cachedFieldsAndFragmentNames,\r\n        comparedFragmentPairs,\r\n        areMutuallyExclusive,\r\n        fragmentName1,\r\n        fragmentName2,\r\n      );\r\n    }\r\n  }\r\n\r\n  return conflicts;\r\n} // Collect all Conflicts \"within\" one collection of fields.\r\n\r\nfunction collectConflictsWithin(\r\n  context,\r\n  conflicts,\r\n  cachedFieldsAndFragmentNames,\r\n  comparedFragmentPairs,\r\n  fieldMap,\r\n) {\r\n  // A field map is a keyed collection, where each key represents a response\r\n  // name and the value at that key is a list of all fields which provide that\r\n  // response name. For every response name, if there are multiple fields, they\r\n  // must be compared to find a potential conflict.\r\n  for (const [responseName, fields] of Object.entries(fieldMap)) {\r\n    // This compares every field in the list to every other field in this list\r\n    // (except to itself). If the list only has one item, nothing needs to\r\n    // be compared.\r\n    if (fields.length > 1) {\r\n      for (let i = 0; i < fields.length; i++) {\r\n        for (let j = i + 1; j < fields.length; j++) {\r\n          const conflict = findConflict(\r\n            context,\r\n            cachedFieldsAndFragmentNames,\r\n            comparedFragmentPairs,\r\n            false, // within one collection is never mutually exclusive\r\n            responseName,\r\n            fields[i],\r\n            fields[j],\r\n          );\r\n\r\n          if (conflict) {\r\n            conflicts.push(conflict);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n} // Collect all Conflicts between two collections of fields. This is similar to,\r\n// but different from the `collectConflictsWithin` function above. This check\r\n// assumes that `collectConflictsWithin` has already been called on each\r\n// provided collection of fields. This is true because this validator traverses\r\n// each individual selection set.\r\n\r\nfunction collectConflictsBetween(\r\n  context,\r\n  conflicts,\r\n  cachedFieldsAndFragmentNames,\r\n  comparedFragmentPairs,\r\n  parentFieldsAreMutuallyExclusive,\r\n  fieldMap1,\r\n  fieldMap2,\r\n) {\r\n  // A field map is a keyed collection, where each key represents a response\r\n  // name and the value at that key is a list of all fields which provide that\r\n  // response name. For any response name which appears in both provided field\r\n  // maps, each field from the first field map must be compared to every field\r\n  // in the second field map to find potential conflicts.\r\n  for (const [responseName, fields1] of Object.entries(fieldMap1)) {\r\n    const fields2 = fieldMap2[responseName];\r\n\r\n    if (fields2) {\r\n      for (const field1 of fields1) {\r\n        for (const field2 of fields2) {\r\n          const conflict = findConflict(\r\n            context,\r\n            cachedFieldsAndFragmentNames,\r\n            comparedFragmentPairs,\r\n            parentFieldsAreMutuallyExclusive,\r\n            responseName,\r\n            field1,\r\n            field2,\r\n          );\r\n\r\n          if (conflict) {\r\n            conflicts.push(conflict);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n} // Determines if there is a conflict between two particular fields, including\r\n// comparing their sub-fields.\r\n\r\nfunction findConflict(\r\n  context,\r\n  cachedFieldsAndFragmentNames,\r\n  comparedFragmentPairs,\r\n  parentFieldsAreMutuallyExclusive,\r\n  responseName,\r\n  field1,\r\n  field2,\r\n) {\r\n  const [parentType1, node1, def1] = field1;\r\n  const [parentType2, node2, def2] = field2; // If it is known that two fields could not possibly apply at the same\r\n  // time, due to the parent types, then it is safe to permit them to diverge\r\n  // in aliased field or arguments used as they will not present any ambiguity\r\n  // by differing.\r\n  // It is known that two parent types could never overlap if they are\r\n  // different Object types. Interface or Union types might overlap - if not\r\n  // in the current state of the schema, then perhaps in some future version,\r\n  // thus may not safely diverge.\r\n\r\n  const areMutuallyExclusive =\r\n    parentFieldsAreMutuallyExclusive ||\r\n    (parentType1 !== parentType2 &&\r\n      isObjectType(parentType1) &&\r\n      isObjectType(parentType2));\r\n\r\n  if (!areMutuallyExclusive) {\r\n    // Two aliases must refer to the same field.\r\n    const name1 = node1.name.value;\r\n    const name2 = node2.name.value;\r\n\r\n    if (name1 !== name2) {\r\n      return [\r\n        [responseName, `\"${name1}\" and \"${name2}\" are different fields`],\r\n        [node1],\r\n        [node2],\r\n      ];\r\n    } // Two field calls must have the same arguments.\r\n\r\n    if (stringifyArguments(node1) !== stringifyArguments(node2)) {\r\n      return [\r\n        [responseName, 'they have differing arguments'],\r\n        [node1],\r\n        [node2],\r\n      ];\r\n    }\r\n  } // The return type for each field.\r\n\r\n  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;\r\n  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;\r\n\r\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\r\n    return [\r\n      [\r\n        responseName,\r\n        `they return conflicting types \"${inspect(type1)}\" and \"${inspect(\r\n          type2,\r\n        )}\"`,\r\n      ],\r\n      [node1],\r\n      [node2],\r\n    ];\r\n  } // Collect and compare sub-fields. Use the same \"visited fragment names\" list\r\n  // for both collections so fields in a fragment reference are never\r\n  // compared to themselves.\r\n\r\n  const selectionSet1 = node1.selectionSet;\r\n  const selectionSet2 = node2.selectionSet;\r\n\r\n  if (selectionSet1 && selectionSet2) {\r\n    const conflicts = findConflictsBetweenSubSelectionSets(\r\n      context,\r\n      cachedFieldsAndFragmentNames,\r\n      comparedFragmentPairs,\r\n      areMutuallyExclusive,\r\n      getNamedType(type1),\r\n      selectionSet1,\r\n      getNamedType(type2),\r\n      selectionSet2,\r\n    );\r\n    return subfieldConflicts(conflicts, responseName, node1, node2);\r\n  }\r\n}\r\n\r\nfunction stringifyArguments(fieldNode) {\r\n  var _fieldNode$arguments;\r\n\r\n  // FIXME https://github.com/graphql/graphql-js/issues/2203\r\n  const args =\r\n    /* c8 ignore next */\r\n    (_fieldNode$arguments = fieldNode.arguments) !== null &&\r\n    _fieldNode$arguments !== void 0\r\n      ? _fieldNode$arguments\r\n      : [];\r\n  const inputObjectWithArgs = {\r\n    kind: Kind.OBJECT,\r\n    fields: args.map((argNode) => ({\r\n      kind: Kind.OBJECT_FIELD,\r\n      name: argNode.name,\r\n      value: argNode.value,\r\n    })),\r\n  };\r\n  return print(sortValueNode(inputObjectWithArgs));\r\n} // Two types conflict if both types could not apply to a value simultaneously.\r\n// Composite types are ignored as their individual field types will be compared\r\n// later recursively. However List and Non-Null types must match.\r\n\r\nfunction doTypesConflict(type1, type2) {\r\n  if (isListType(type1)) {\r\n    return isListType(type2)\r\n      ? doTypesConflict(type1.ofType, type2.ofType)\r\n      : true;\r\n  }\r\n\r\n  if (isListType(type2)) {\r\n    return true;\r\n  }\r\n\r\n  if (isNonNullType(type1)) {\r\n    return isNonNullType(type2)\r\n      ? doTypesConflict(type1.ofType, type2.ofType)\r\n      : true;\r\n  }\r\n\r\n  if (isNonNullType(type2)) {\r\n    return true;\r\n  }\r\n\r\n  if (isLeafType(type1) || isLeafType(type2)) {\r\n    return type1 !== type2;\r\n  }\r\n\r\n  return false;\r\n} // Given a selection set, return the collection of fields (a mapping of response\r\n// name to field nodes and definitions) as well as a list of fragment names\r\n// referenced via fragment spreads.\r\n\r\nfunction getFieldsAndFragmentNames(\r\n  context,\r\n  cachedFieldsAndFragmentNames,\r\n  parentType,\r\n  selectionSet,\r\n) {\r\n  const cached = cachedFieldsAndFragmentNames.get(selectionSet);\r\n\r\n  if (cached) {\r\n    return cached;\r\n  }\r\n\r\n  const nodeAndDefs = Object.create(null);\r\n  const fragmentNames = Object.create(null);\r\n\r\n  _collectFieldsAndFragmentNames(\r\n    context,\r\n    parentType,\r\n    selectionSet,\r\n    nodeAndDefs,\r\n    fragmentNames,\r\n  );\r\n\r\n  const result = [nodeAndDefs, Object.keys(fragmentNames)];\r\n  cachedFieldsAndFragmentNames.set(selectionSet, result);\r\n  return result;\r\n} // Given a reference to a fragment, return the represented collection of fields\r\n// as well as a list of nested fragment names referenced via fragment spreads.\r\n\r\nfunction getReferencedFieldsAndFragmentNames(\r\n  context,\r\n  cachedFieldsAndFragmentNames,\r\n  fragment,\r\n) {\r\n  // Short-circuit building a type from the node if possible.\r\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\r\n\r\n  if (cached) {\r\n    return cached;\r\n  }\r\n\r\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\r\n  return getFieldsAndFragmentNames(\r\n    context,\r\n    cachedFieldsAndFragmentNames,\r\n    fragmentType,\r\n    fragment.selectionSet,\r\n  );\r\n}\r\n\r\nfunction _collectFieldsAndFragmentNames(\r\n  context,\r\n  parentType,\r\n  selectionSet,\r\n  nodeAndDefs,\r\n  fragmentNames,\r\n) {\r\n  for (const selection of selectionSet.selections) {\r\n    switch (selection.kind) {\r\n      case Kind.FIELD: {\r\n        const fieldName = selection.name.value;\r\n        let fieldDef;\r\n\r\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\r\n          fieldDef = parentType.getFields()[fieldName];\r\n        }\r\n\r\n        const responseName = selection.alias\r\n          ? selection.alias.value\r\n          : fieldName;\r\n\r\n        if (!nodeAndDefs[responseName]) {\r\n          nodeAndDefs[responseName] = [];\r\n        }\r\n\r\n        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);\r\n        break;\r\n      }\r\n\r\n      case Kind.FRAGMENT_SPREAD:\r\n        fragmentNames[selection.name.value] = true;\r\n        break;\r\n\r\n      case Kind.INLINE_FRAGMENT: {\r\n        const typeCondition = selection.typeCondition;\r\n        const inlineFragmentType = typeCondition\r\n          ? typeFromAST(context.getSchema(), typeCondition)\r\n          : parentType;\r\n\r\n        _collectFieldsAndFragmentNames(\r\n          context,\r\n          inlineFragmentType,\r\n          selection.selectionSet,\r\n          nodeAndDefs,\r\n          fragmentNames,\r\n        );\r\n\r\n        break;\r\n      }\r\n    }\r\n  }\r\n} // Given a series of Conflicts which occurred between two sub-fields, generate\r\n// a single Conflict.\r\n\r\nfunction subfieldConflicts(conflicts, responseName, node1, node2) {\r\n  if (conflicts.length > 0) {\r\n    return [\r\n      [responseName, conflicts.map(([reason]) => reason)],\r\n      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],\r\n      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()],\r\n    ];\r\n  }\r\n}\r\n/**\r\n * A way to keep track of pairs of things when the ordering of the pair does not matter.\r\n */\r\n\r\nclass PairSet {\r\n  constructor() {\r\n    this._data = new Map();\r\n  }\r\n\r\n  has(a, b, areMutuallyExclusive) {\r\n    var _this$_data$get;\r\n\r\n    const [key1, key2] = a < b ? [a, b] : [b, a];\r\n    const result =\r\n      (_this$_data$get = this._data.get(key1)) === null ||\r\n      _this$_data$get === void 0\r\n        ? void 0\r\n        : _this$_data$get.get(key2);\r\n\r\n    if (result === undefined) {\r\n      return false;\r\n    } // areMutuallyExclusive being false is a superset of being true, hence if\r\n    // we want to know if this PairSet \"has\" these two with no exclusivity,\r\n    // we have to ensure it was added as such.\r\n\r\n    return areMutuallyExclusive ? true : areMutuallyExclusive === result;\r\n  }\r\n\r\n  add(a, b, areMutuallyExclusive) {\r\n    const [key1, key2] = a < b ? [a, b] : [b, a];\r\n\r\n    const map = this._data.get(key1);\r\n\r\n    if (map === undefined) {\r\n      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));\r\n    } else {\r\n      map.set(key2, areMutuallyExclusive);\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}