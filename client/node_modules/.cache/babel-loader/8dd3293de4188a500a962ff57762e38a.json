{"ast":null,"code":"import { syntaxError } from '../error/syntaxError.mjs';\nimport { Token } from './ast.mjs';\nimport { dedentBlockStringLines } from './blockString.mjs';\nimport { isDigit, isNameContinue, isNameStart } from './characterClasses.mjs';\nimport { TokenKind } from './tokenKind.mjs';\n/**\r\n * Given a Source object, creates a Lexer for that source.\r\n * A Lexer is a stateful stream generator in that every time\r\n * it is advanced, it returns the next token in the Source. Assuming the\r\n * source lexes, the final Token emitted by the lexer will be of kind\r\n * EOF, after which the lexer will repeatedly return the same EOF token\r\n * whenever called.\r\n */\n\nexport class Lexer {\n  /**\r\n   * The previously focused non-ignored token.\r\n   */\n\n  /**\r\n   * The currently focused non-ignored token.\r\n   */\n\n  /**\r\n   * The (1-indexed) line containing the current token.\r\n   */\n\n  /**\r\n   * The character offset at which the current line begins.\r\n   */\n  constructor(source) {\n    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Lexer';\n  }\n  /**\r\n   * Advances the token stream to the next non-ignored token.\r\n   */\n\n\n  advance() {\n    this.lastToken = this.token;\n    const token = this.token = this.lookahead();\n    return token;\n  }\n  /**\r\n   * Looks ahead and returns the next non-ignored token, but does not change\r\n   * the state of Lexer.\r\n   */\n\n\n  lookahead() {\n    let token = this.token;\n\n    if (token.kind !== TokenKind.EOF) {\n      do {\n        if (token.next) {\n          token = token.next;\n        } else {\n          // Read the next token and form a link in the token linked-list.\n          const nextToken = readNextToken(this, token.end); // @ts-expect-error next is only mutable during parsing.\n\n          token.next = nextToken; // @ts-expect-error prev is only mutable during parsing.\n\n          nextToken.prev = token;\n          token = nextToken;\n        }\n      } while (token.kind === TokenKind.COMMENT);\n    }\n\n    return token;\n  }\n\n}\n/**\r\n * @internal\r\n */\n\nexport function isPunctuatorTokenKind(kind) {\n  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;\n}\n/**\r\n * A Unicode scalar value is any Unicode code point except surrogate code\r\n * points. In other words, the inclusive ranges of values 0x0000 to 0xD7FF and\r\n * 0xE000 to 0x10FFFF.\r\n *\r\n * SourceCharacter ::\r\n *   - \"Any Unicode scalar value\"\r\n */\n\nfunction isUnicodeScalarValue(code) {\n  return code >= 0x0000 && code <= 0xd7ff || code >= 0xe000 && code <= 0x10ffff;\n}\n/**\r\n * The GraphQL specification defines source text as a sequence of unicode scalar\r\n * values (which Unicode defines to exclude surrogate code points). However\r\n * JavaScript defines strings as a sequence of UTF-16 code units which may\r\n * include surrogates. A surrogate pair is a valid source character as it\r\n * encodes a supplementary code point (above U+FFFF), but unpaired surrogate\r\n * code points are not valid source characters.\r\n */\n\n\nfunction isSupplementaryCodePoint(body, location) {\n  return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));\n}\n\nfunction isLeadingSurrogate(code) {\n  return code >= 0xd800 && code <= 0xdbff;\n}\n\nfunction isTrailingSurrogate(code) {\n  return code >= 0xdc00 && code <= 0xdfff;\n}\n/**\r\n * Prints the code point (or end of file reference) at a given location in a\r\n * source for use in error messages.\r\n *\r\n * Printable ASCII is printed quoted, while other points are printed in Unicode\r\n * code point form (ie. U+1234).\r\n */\n\n\nfunction printCodePointAt(lexer, location) {\n  const code = lexer.source.body.codePointAt(location);\n\n  if (code === undefined) {\n    return TokenKind.EOF;\n  } else if (code >= 0x0020 && code <= 0x007e) {\n    // Printable ASCII\n    const char = String.fromCodePoint(code);\n    return char === '\"' ? \"'\\\"'\" : `\"${char}\"`;\n  } // Unicode code point\n\n\n  return 'U+' + code.toString(16).toUpperCase().padStart(4, '0');\n}\n/**\r\n * Create a token with line and column location information.\r\n */\n\n\nfunction createToken(lexer, kind, start, end, value) {\n  const line = lexer.line;\n  const col = 1 + start - lexer.lineStart;\n  return new Token(kind, start, end, line, col, value);\n}\n/**\r\n * Gets the next token from the source starting at the given position.\r\n *\r\n * This skips over whitespace until it finds the next lexable token, then lexes\r\n * punctuators immediately or calls the appropriate helper function for more\r\n * complicated tokens.\r\n */\n\n\nfunction readNextToken(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // SourceCharacter\n\n    switch (code) {\n      // Ignored ::\n      //   - UnicodeBOM\n      //   - WhiteSpace\n      //   - LineTerminator\n      //   - Comment\n      //   - Comma\n      //\n      // UnicodeBOM :: \"Byte Order Mark (U+FEFF)\"\n      //\n      // WhiteSpace ::\n      //   - \"Horizontal Tab (U+0009)\"\n      //   - \"Space (U+0020)\"\n      //\n      // Comma :: ,\n      case 0xfeff: // <BOM>\n\n      case 0x0009: // \\t\n\n      case 0x0020: // <space>\n\n      case 0x002c:\n        // ,\n        ++position;\n        continue;\n      // LineTerminator ::\n      //   - \"New Line (U+000A)\"\n      //   - \"Carriage Return (U+000D)\" [lookahead != \"New Line (U+000A)\"]\n      //   - \"Carriage Return (U+000D)\" \"New Line (U+000A)\"\n\n      case 0x000a:\n        // \\n\n        ++position;\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n\n      case 0x000d:\n        // \\r\n        if (body.charCodeAt(position + 1) === 0x000a) {\n          position += 2;\n        } else {\n          ++position;\n        }\n\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n      // Comment\n\n      case 0x0023:\n        // #\n        return readComment(lexer, position);\n      // Token ::\n      //   - Punctuator\n      //   - Name\n      //   - IntValue\n      //   - FloatValue\n      //   - StringValue\n      //\n      // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }\n\n      case 0x0021:\n        // !\n        return createToken(lexer, TokenKind.BANG, position, position + 1);\n\n      case 0x0024:\n        // $\n        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);\n\n      case 0x0026:\n        // &\n        return createToken(lexer, TokenKind.AMP, position, position + 1);\n\n      case 0x0028:\n        // (\n        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);\n\n      case 0x0029:\n        // )\n        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);\n\n      case 0x002e:\n        // .\n        if (body.charCodeAt(position + 1) === 0x002e && body.charCodeAt(position + 2) === 0x002e) {\n          return createToken(lexer, TokenKind.SPREAD, position, position + 3);\n        }\n\n        break;\n\n      case 0x003a:\n        // :\n        return createToken(lexer, TokenKind.COLON, position, position + 1);\n\n      case 0x003d:\n        // =\n        return createToken(lexer, TokenKind.EQUALS, position, position + 1);\n\n      case 0x0040:\n        // @\n        return createToken(lexer, TokenKind.AT, position, position + 1);\n\n      case 0x005b:\n        // [\n        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);\n\n      case 0x005d:\n        // ]\n        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);\n\n      case 0x007b:\n        // {\n        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);\n\n      case 0x007c:\n        // |\n        return createToken(lexer, TokenKind.PIPE, position, position + 1);\n\n      case 0x007d:\n        // }\n        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);\n      // StringValue\n\n      case 0x0022:\n        // \"\n        if (body.charCodeAt(position + 1) === 0x0022 && body.charCodeAt(position + 2) === 0x0022) {\n          return readBlockString(lexer, position);\n        }\n\n        return readString(lexer, position);\n    } // IntValue | FloatValue (Digit | -)\n\n\n    if (isDigit(code) || code === 0x002d) {\n      return readNumber(lexer, position, code);\n    } // Name\n\n\n    if (isNameStart(code)) {\n      return readName(lexer, position);\n    }\n\n    throw syntaxError(lexer.source, position, code === 0x0027 ? 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?' : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`);\n  }\n\n  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);\n}\n/**\r\n * Reads a comment token from the source file.\r\n *\r\n * ```\r\n * Comment :: # CommentChar* [lookahead != CommentChar]\r\n *\r\n * CommentChar :: SourceCharacter but not LineTerminator\r\n * ```\r\n */\n\n\nfunction readComment(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // LineTerminator (\\n | \\r)\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(lexer, TokenKind.COMMENT, start, position, body.slice(start + 1, position));\n}\n/**\r\n * Reads a number token from the source file, either a FloatValue or an IntValue\r\n * depending on whether a FractionalPart or ExponentPart is encountered.\r\n *\r\n * ```\r\n * IntValue :: IntegerPart [lookahead != {Digit, `.`, NameStart}]\r\n *\r\n * IntegerPart ::\r\n *   - NegativeSign? 0\r\n *   - NegativeSign? NonZeroDigit Digit*\r\n *\r\n * NegativeSign :: -\r\n *\r\n * NonZeroDigit :: Digit but not `0`\r\n *\r\n * FloatValue ::\r\n *   - IntegerPart FractionalPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\r\n *   - IntegerPart FractionalPart [lookahead != {Digit, `.`, NameStart}]\r\n *   - IntegerPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\r\n *\r\n * FractionalPart :: . Digit+\r\n *\r\n * ExponentPart :: ExponentIndicator Sign? Digit+\r\n *\r\n * ExponentIndicator :: one of `e` `E`\r\n *\r\n * Sign :: one of + -\r\n * ```\r\n */\n\n\nfunction readNumber(lexer, start, firstCode) {\n  const body = lexer.source.body;\n  let position = start;\n  let code = firstCode;\n  let isFloat = false; // NegativeSign (-)\n\n  if (code === 0x002d) {\n    code = body.charCodeAt(++position);\n  } // Zero (0)\n\n\n  if (code === 0x0030) {\n    code = body.charCodeAt(++position);\n\n    if (isDigit(code)) {\n      throw syntaxError(lexer.source, position, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position)}.`);\n    }\n  } else {\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Full stop (.)\n\n\n  if (code === 0x002e) {\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // E e\n\n\n  if (code === 0x0045 || code === 0x0065) {\n    isFloat = true;\n    code = body.charCodeAt(++position); // + -\n\n    if (code === 0x002b || code === 0x002d) {\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or NameStart\n\n\n  if (code === 0x002e || isNameStart(code)) {\n    throw syntaxError(lexer.source, position, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position)}.`);\n  }\n\n  return createToken(lexer, isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, body.slice(start, position));\n}\n/**\r\n * Returns the new position in the source after reading one or more digits.\r\n */\n\n\nfunction readDigits(lexer, start, firstCode) {\n  if (!isDigit(firstCode)) {\n    throw syntaxError(lexer.source, start, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start)}.`);\n  }\n\n  const body = lexer.source.body;\n  let position = start + 1; // +1 to skip first firstCode\n\n  while (isDigit(body.charCodeAt(position))) {\n    ++position;\n  }\n\n  return position;\n}\n/**\r\n * Reads a single-quote string token from the source file.\r\n *\r\n * ```\r\n * StringValue ::\r\n *   - `\"\"` [lookahead != `\"`]\r\n *   - `\"` StringCharacter+ `\"`\r\n *\r\n * StringCharacter ::\r\n *   - SourceCharacter but not `\"` or `\\` or LineTerminator\r\n *   - `\\u` EscapedUnicode\r\n *   - `\\` EscapedCharacter\r\n *\r\n * EscapedUnicode ::\r\n *   - `{` HexDigit+ `}`\r\n *   - HexDigit HexDigit HexDigit HexDigit\r\n *\r\n * EscapedCharacter :: one of `\"` `\\` `/` `b` `f` `n` `r` `t`\r\n * ```\r\n */\n\n\nfunction readString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n  let chunkStart = position;\n  let value = '';\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Quote (\")\n\n    if (code === 0x0022) {\n      value += body.slice(chunkStart, position);\n      return createToken(lexer, TokenKind.STRING, start, position + 1, value);\n    } // Escape Sequence (\\)\n\n\n    if (code === 0x005c) {\n      value += body.slice(chunkStart, position);\n      const escape = body.charCodeAt(position + 1) === 0x0075 // u\n      ? body.charCodeAt(position + 2) === 0x007b // {\n      ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);\n      value += escape.value;\n      position += escape.size;\n      chunkStart = position;\n      continue;\n    } // LineTerminator (\\n | \\r)\n\n\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    } // SourceCharacter\n\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n} // The string value and lexed size of an escape sequence.\n\n\nfunction readEscapedUnicodeVariableWidth(lexer, position) {\n  const body = lexer.source.body;\n  let point = 0;\n  let size = 3; // Cannot be larger than 12 chars (\\u{00000000}).\n\n  while (size < 12) {\n    const code = body.charCodeAt(position + size++); // Closing Brace (})\n\n    if (code === 0x007d) {\n      // Must be at least 5 chars (\\u{0}) and encode a Unicode scalar value.\n      if (size < 5 || !isUnicodeScalarValue(point)) {\n        break;\n      }\n\n      return {\n        value: String.fromCodePoint(point),\n        size\n      };\n    } // Append this hex digit to the code point.\n\n\n    point = point << 4 | readHexDigit(code);\n\n    if (point < 0) {\n      break;\n    }\n  }\n\n  throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: \"${body.slice(position, position + size)}\".`);\n}\n\nfunction readEscapedUnicodeFixedWidth(lexer, position) {\n  const body = lexer.source.body;\n  const code = read16BitHexCode(body, position + 2);\n\n  if (isUnicodeScalarValue(code)) {\n    return {\n      value: String.fromCodePoint(code),\n      size: 6\n    };\n  } // GraphQL allows JSON-style surrogate pair escape sequences, but only when\n  // a valid pair is formed.\n\n\n  if (isLeadingSurrogate(code)) {\n    // \\u\n    if (body.charCodeAt(position + 6) === 0x005c && body.charCodeAt(position + 7) === 0x0075) {\n      const trailingCode = read16BitHexCode(body, position + 8);\n\n      if (isTrailingSurrogate(trailingCode)) {\n        // JavaScript defines strings as a sequence of UTF-16 code units and\n        // encodes Unicode code points above U+FFFF using a surrogate pair of\n        // code units. Since this is a surrogate pair escape sequence, just\n        // include both codes into the JavaScript string value. Had JavaScript\n        // not been internally based on UTF-16, then this surrogate pair would\n        // be decoded to retrieve the supplementary code point.\n        return {\n          value: String.fromCodePoint(code, trailingCode),\n          size: 12\n        };\n      }\n    }\n  }\n\n  throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: \"${body.slice(position, position + 6)}\".`);\n}\n/**\r\n * Reads four hexadecimal characters and returns the positive integer that 16bit\r\n * hexadecimal string represents. For example, \"000f\" will return 15, and \"dead\"\r\n * will return 57005.\r\n *\r\n * Returns a negative number if any char was not a valid hexadecimal digit.\r\n */\n\n\nfunction read16BitHexCode(body, position) {\n  // readHexDigit() returns -1 on error. ORing a negative value with any other\n  // value always produces a negative value.\n  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));\n}\n/**\r\n * Reads a hexadecimal character and returns its positive integer value (0-15).\r\n *\r\n * '0' becomes 0, '9' becomes 9\r\n * 'A' becomes 10, 'F' becomes 15\r\n * 'a' becomes 10, 'f' becomes 15\r\n *\r\n * Returns -1 if the provided character code was not a valid hexadecimal digit.\r\n *\r\n * HexDigit :: one of\r\n *   - `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\r\n *   - `A` `B` `C` `D` `E` `F`\r\n *   - `a` `b` `c` `d` `e` `f`\r\n */\n\n\nfunction readHexDigit(code) {\n  return code >= 0x0030 && code <= 0x0039 // 0-9\n  ? code - 0x0030 : code >= 0x0041 && code <= 0x0046 // A-F\n  ? code - 0x0037 : code >= 0x0061 && code <= 0x0066 // a-f\n  ? code - 0x0057 : -1;\n}\n/**\r\n * | Escaped Character | Code Point | Character Name               |\r\n * | ----------------- | ---------- | ---------------------------- |\r\n * | `\"`               | U+0022     | double quote                 |\r\n * | `\\`               | U+005C     | reverse solidus (back slash) |\r\n * | `/`               | U+002F     | solidus (forward slash)      |\r\n * | `b`               | U+0008     | backspace                    |\r\n * | `f`               | U+000C     | form feed                    |\r\n * | `n`               | U+000A     | line feed (new line)         |\r\n * | `r`               | U+000D     | carriage return              |\r\n * | `t`               | U+0009     | horizontal tab               |\r\n */\n\n\nfunction readEscapedCharacter(lexer, position) {\n  const body = lexer.source.body;\n  const code = body.charCodeAt(position + 1);\n\n  switch (code) {\n    case 0x0022:\n      // \"\n      return {\n        value: '\\u0022',\n        size: 2\n      };\n\n    case 0x005c:\n      // \\\n      return {\n        value: '\\u005c',\n        size: 2\n      };\n\n    case 0x002f:\n      // /\n      return {\n        value: '\\u002f',\n        size: 2\n      };\n\n    case 0x0062:\n      // b\n      return {\n        value: '\\u0008',\n        size: 2\n      };\n\n    case 0x0066:\n      // f\n      return {\n        value: '\\u000c',\n        size: 2\n      };\n\n    case 0x006e:\n      // n\n      return {\n        value: '\\u000a',\n        size: 2\n      };\n\n    case 0x0072:\n      // r\n      return {\n        value: '\\u000d',\n        size: 2\n      };\n\n    case 0x0074:\n      // t\n      return {\n        value: '\\u0009',\n        size: 2\n      };\n  }\n\n  throw syntaxError(lexer.source, position, `Invalid character escape sequence: \"${body.slice(position, position + 2)}\".`);\n}\n/**\r\n * Reads a block string token from the source file.\r\n *\r\n * ```\r\n * StringValue ::\r\n *   - `\"\"\"` BlockStringCharacter* `\"\"\"`\r\n *\r\n * BlockStringCharacter ::\r\n *   - SourceCharacter but not `\"\"\"` or `\\\"\"\"`\r\n *   - `\\\"\"\"`\r\n * ```\r\n */\n\n\nfunction readBlockString(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let lineStart = lexer.lineStart;\n  let position = start + 3;\n  let chunkStart = position;\n  let currentLine = '';\n  const blockLines = [];\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position); // Closing Triple-Quote (\"\"\")\n\n    if (code === 0x0022 && body.charCodeAt(position + 1) === 0x0022 && body.charCodeAt(position + 2) === 0x0022) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n      const token = createToken(lexer, TokenKind.BLOCK_STRING, start, position + 3, // Return a string of the lines joined with U+000A.\n      dedentBlockStringLines(blockLines).join('\\n'));\n      lexer.line += blockLines.length - 1;\n      lexer.lineStart = lineStart;\n      return token;\n    } // Escaped Triple-Quote (\\\"\"\")\n\n\n    if (code === 0x005c && body.charCodeAt(position + 1) === 0x0022 && body.charCodeAt(position + 2) === 0x0022 && body.charCodeAt(position + 3) === 0x0022) {\n      currentLine += body.slice(chunkStart, position);\n      chunkStart = position + 1; // skip only slash\n\n      position += 4;\n      continue;\n    } // LineTerminator\n\n\n    if (code === 0x000a || code === 0x000d) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n\n      if (code === 0x000d && body.charCodeAt(position + 1) === 0x000a) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      currentLine = '';\n      chunkStart = position;\n      lineStart = position;\n      continue;\n    } // SourceCharacter\n\n\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n}\n/**\r\n * Reads an alphanumeric + underscore name from the source.\r\n *\r\n * ```\r\n * Name ::\r\n *   - NameStart NameContinue* [lookahead != NameContinue]\r\n * ```\r\n */\n\n\nfunction readName(lexer, start) {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position);\n\n    if (isNameContinue(code)) {\n      ++position;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(lexer, TokenKind.NAME, start, position, body.slice(start, position));\n}","map":{"version":3,"names":["syntaxError","Token","dedentBlockStringLines","isDigit","isNameContinue","isNameStart","TokenKind","Lexer","constructor","source","startOfFileToken","SOF","lastToken","token","line","lineStart","Symbol","toStringTag","advance","lookahead","kind","EOF","next","nextToken","readNextToken","end","prev","COMMENT","isPunctuatorTokenKind","BANG","DOLLAR","AMP","PAREN_L","PAREN_R","SPREAD","COLON","EQUALS","AT","BRACKET_L","BRACKET_R","BRACE_L","PIPE","BRACE_R","isUnicodeScalarValue","code","isSupplementaryCodePoint","body","location","isLeadingSurrogate","charCodeAt","isTrailingSurrogate","printCodePointAt","lexer","codePointAt","undefined","char","String","fromCodePoint","toString","toUpperCase","padStart","createToken","start","value","col","bodyLength","length","position","readComment","readBlockString","readString","readNumber","readName","slice","firstCode","isFloat","readDigits","FLOAT","INT","chunkStart","STRING","escape","readEscapedUnicodeVariableWidth","readEscapedUnicodeFixedWidth","readEscapedCharacter","size","point","readHexDigit","read16BitHexCode","trailingCode","currentLine","blockLines","push","BLOCK_STRING","join","NAME"],"sources":["C:/Users/Dani/Desktop/projects/dream-small/dream-small/node_modules/graphql/language/lexer.mjs"],"sourcesContent":["import { syntaxError } from '../error/syntaxError.mjs';\r\nimport { Token } from './ast.mjs';\r\nimport { dedentBlockStringLines } from './blockString.mjs';\r\nimport { isDigit, isNameContinue, isNameStart } from './characterClasses.mjs';\r\nimport { TokenKind } from './tokenKind.mjs';\r\n/**\r\n * Given a Source object, creates a Lexer for that source.\r\n * A Lexer is a stateful stream generator in that every time\r\n * it is advanced, it returns the next token in the Source. Assuming the\r\n * source lexes, the final Token emitted by the lexer will be of kind\r\n * EOF, after which the lexer will repeatedly return the same EOF token\r\n * whenever called.\r\n */\r\n\r\nexport class Lexer {\r\n  /**\r\n   * The previously focused non-ignored token.\r\n   */\r\n\r\n  /**\r\n   * The currently focused non-ignored token.\r\n   */\r\n\r\n  /**\r\n   * The (1-indexed) line containing the current token.\r\n   */\r\n\r\n  /**\r\n   * The character offset at which the current line begins.\r\n   */\r\n  constructor(source) {\r\n    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);\r\n    this.source = source;\r\n    this.lastToken = startOfFileToken;\r\n    this.token = startOfFileToken;\r\n    this.line = 1;\r\n    this.lineStart = 0;\r\n  }\r\n\r\n  get [Symbol.toStringTag]() {\r\n    return 'Lexer';\r\n  }\r\n  /**\r\n   * Advances the token stream to the next non-ignored token.\r\n   */\r\n\r\n  advance() {\r\n    this.lastToken = this.token;\r\n    const token = (this.token = this.lookahead());\r\n    return token;\r\n  }\r\n  /**\r\n   * Looks ahead and returns the next non-ignored token, but does not change\r\n   * the state of Lexer.\r\n   */\r\n\r\n  lookahead() {\r\n    let token = this.token;\r\n\r\n    if (token.kind !== TokenKind.EOF) {\r\n      do {\r\n        if (token.next) {\r\n          token = token.next;\r\n        } else {\r\n          // Read the next token and form a link in the token linked-list.\r\n          const nextToken = readNextToken(this, token.end); // @ts-expect-error next is only mutable during parsing.\r\n\r\n          token.next = nextToken; // @ts-expect-error prev is only mutable during parsing.\r\n\r\n          nextToken.prev = token;\r\n          token = nextToken;\r\n        }\r\n      } while (token.kind === TokenKind.COMMENT);\r\n    }\r\n\r\n    return token;\r\n  }\r\n}\r\n/**\r\n * @internal\r\n */\r\n\r\nexport function isPunctuatorTokenKind(kind) {\r\n  return (\r\n    kind === TokenKind.BANG ||\r\n    kind === TokenKind.DOLLAR ||\r\n    kind === TokenKind.AMP ||\r\n    kind === TokenKind.PAREN_L ||\r\n    kind === TokenKind.PAREN_R ||\r\n    kind === TokenKind.SPREAD ||\r\n    kind === TokenKind.COLON ||\r\n    kind === TokenKind.EQUALS ||\r\n    kind === TokenKind.AT ||\r\n    kind === TokenKind.BRACKET_L ||\r\n    kind === TokenKind.BRACKET_R ||\r\n    kind === TokenKind.BRACE_L ||\r\n    kind === TokenKind.PIPE ||\r\n    kind === TokenKind.BRACE_R\r\n  );\r\n}\r\n/**\r\n * A Unicode scalar value is any Unicode code point except surrogate code\r\n * points. In other words, the inclusive ranges of values 0x0000 to 0xD7FF and\r\n * 0xE000 to 0x10FFFF.\r\n *\r\n * SourceCharacter ::\r\n *   - \"Any Unicode scalar value\"\r\n */\r\n\r\nfunction isUnicodeScalarValue(code) {\r\n  return (\r\n    (code >= 0x0000 && code <= 0xd7ff) || (code >= 0xe000 && code <= 0x10ffff)\r\n  );\r\n}\r\n/**\r\n * The GraphQL specification defines source text as a sequence of unicode scalar\r\n * values (which Unicode defines to exclude surrogate code points). However\r\n * JavaScript defines strings as a sequence of UTF-16 code units which may\r\n * include surrogates. A surrogate pair is a valid source character as it\r\n * encodes a supplementary code point (above U+FFFF), but unpaired surrogate\r\n * code points are not valid source characters.\r\n */\r\n\r\nfunction isSupplementaryCodePoint(body, location) {\r\n  return (\r\n    isLeadingSurrogate(body.charCodeAt(location)) &&\r\n    isTrailingSurrogate(body.charCodeAt(location + 1))\r\n  );\r\n}\r\n\r\nfunction isLeadingSurrogate(code) {\r\n  return code >= 0xd800 && code <= 0xdbff;\r\n}\r\n\r\nfunction isTrailingSurrogate(code) {\r\n  return code >= 0xdc00 && code <= 0xdfff;\r\n}\r\n/**\r\n * Prints the code point (or end of file reference) at a given location in a\r\n * source for use in error messages.\r\n *\r\n * Printable ASCII is printed quoted, while other points are printed in Unicode\r\n * code point form (ie. U+1234).\r\n */\r\n\r\nfunction printCodePointAt(lexer, location) {\r\n  const code = lexer.source.body.codePointAt(location);\r\n\r\n  if (code === undefined) {\r\n    return TokenKind.EOF;\r\n  } else if (code >= 0x0020 && code <= 0x007e) {\r\n    // Printable ASCII\r\n    const char = String.fromCodePoint(code);\r\n    return char === '\"' ? \"'\\\"'\" : `\"${char}\"`;\r\n  } // Unicode code point\r\n\r\n  return 'U+' + code.toString(16).toUpperCase().padStart(4, '0');\r\n}\r\n/**\r\n * Create a token with line and column location information.\r\n */\r\n\r\nfunction createToken(lexer, kind, start, end, value) {\r\n  const line = lexer.line;\r\n  const col = 1 + start - lexer.lineStart;\r\n  return new Token(kind, start, end, line, col, value);\r\n}\r\n/**\r\n * Gets the next token from the source starting at the given position.\r\n *\r\n * This skips over whitespace until it finds the next lexable token, then lexes\r\n * punctuators immediately or calls the appropriate helper function for more\r\n * complicated tokens.\r\n */\r\n\r\nfunction readNextToken(lexer, start) {\r\n  const body = lexer.source.body;\r\n  const bodyLength = body.length;\r\n  let position = start;\r\n\r\n  while (position < bodyLength) {\r\n    const code = body.charCodeAt(position); // SourceCharacter\r\n\r\n    switch (code) {\r\n      // Ignored ::\r\n      //   - UnicodeBOM\r\n      //   - WhiteSpace\r\n      //   - LineTerminator\r\n      //   - Comment\r\n      //   - Comma\r\n      //\r\n      // UnicodeBOM :: \"Byte Order Mark (U+FEFF)\"\r\n      //\r\n      // WhiteSpace ::\r\n      //   - \"Horizontal Tab (U+0009)\"\r\n      //   - \"Space (U+0020)\"\r\n      //\r\n      // Comma :: ,\r\n      case 0xfeff: // <BOM>\r\n\r\n      case 0x0009: // \\t\r\n\r\n      case 0x0020: // <space>\r\n\r\n      case 0x002c:\r\n        // ,\r\n        ++position;\r\n        continue;\r\n      // LineTerminator ::\r\n      //   - \"New Line (U+000A)\"\r\n      //   - \"Carriage Return (U+000D)\" [lookahead != \"New Line (U+000A)\"]\r\n      //   - \"Carriage Return (U+000D)\" \"New Line (U+000A)\"\r\n\r\n      case 0x000a:\r\n        // \\n\r\n        ++position;\r\n        ++lexer.line;\r\n        lexer.lineStart = position;\r\n        continue;\r\n\r\n      case 0x000d:\r\n        // \\r\r\n        if (body.charCodeAt(position + 1) === 0x000a) {\r\n          position += 2;\r\n        } else {\r\n          ++position;\r\n        }\r\n\r\n        ++lexer.line;\r\n        lexer.lineStart = position;\r\n        continue;\r\n      // Comment\r\n\r\n      case 0x0023:\r\n        // #\r\n        return readComment(lexer, position);\r\n      // Token ::\r\n      //   - Punctuator\r\n      //   - Name\r\n      //   - IntValue\r\n      //   - FloatValue\r\n      //   - StringValue\r\n      //\r\n      // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }\r\n\r\n      case 0x0021:\r\n        // !\r\n        return createToken(lexer, TokenKind.BANG, position, position + 1);\r\n\r\n      case 0x0024:\r\n        // $\r\n        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);\r\n\r\n      case 0x0026:\r\n        // &\r\n        return createToken(lexer, TokenKind.AMP, position, position + 1);\r\n\r\n      case 0x0028:\r\n        // (\r\n        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);\r\n\r\n      case 0x0029:\r\n        // )\r\n        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);\r\n\r\n      case 0x002e:\r\n        // .\r\n        if (\r\n          body.charCodeAt(position + 1) === 0x002e &&\r\n          body.charCodeAt(position + 2) === 0x002e\r\n        ) {\r\n          return createToken(lexer, TokenKind.SPREAD, position, position + 3);\r\n        }\r\n\r\n        break;\r\n\r\n      case 0x003a:\r\n        // :\r\n        return createToken(lexer, TokenKind.COLON, position, position + 1);\r\n\r\n      case 0x003d:\r\n        // =\r\n        return createToken(lexer, TokenKind.EQUALS, position, position + 1);\r\n\r\n      case 0x0040:\r\n        // @\r\n        return createToken(lexer, TokenKind.AT, position, position + 1);\r\n\r\n      case 0x005b:\r\n        // [\r\n        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);\r\n\r\n      case 0x005d:\r\n        // ]\r\n        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);\r\n\r\n      case 0x007b:\r\n        // {\r\n        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);\r\n\r\n      case 0x007c:\r\n        // |\r\n        return createToken(lexer, TokenKind.PIPE, position, position + 1);\r\n\r\n      case 0x007d:\r\n        // }\r\n        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);\r\n      // StringValue\r\n\r\n      case 0x0022:\r\n        // \"\r\n        if (\r\n          body.charCodeAt(position + 1) === 0x0022 &&\r\n          body.charCodeAt(position + 2) === 0x0022\r\n        ) {\r\n          return readBlockString(lexer, position);\r\n        }\r\n\r\n        return readString(lexer, position);\r\n    } // IntValue | FloatValue (Digit | -)\r\n\r\n    if (isDigit(code) || code === 0x002d) {\r\n      return readNumber(lexer, position, code);\r\n    } // Name\r\n\r\n    if (isNameStart(code)) {\r\n      return readName(lexer, position);\r\n    }\r\n\r\n    throw syntaxError(\r\n      lexer.source,\r\n      position,\r\n      code === 0x0027\r\n        ? 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?'\r\n        : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position)\r\n        ? `Unexpected character: ${printCodePointAt(lexer, position)}.`\r\n        : `Invalid character: ${printCodePointAt(lexer, position)}.`,\r\n    );\r\n  }\r\n\r\n  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);\r\n}\r\n/**\r\n * Reads a comment token from the source file.\r\n *\r\n * ```\r\n * Comment :: # CommentChar* [lookahead != CommentChar]\r\n *\r\n * CommentChar :: SourceCharacter but not LineTerminator\r\n * ```\r\n */\r\n\r\nfunction readComment(lexer, start) {\r\n  const body = lexer.source.body;\r\n  const bodyLength = body.length;\r\n  let position = start + 1;\r\n\r\n  while (position < bodyLength) {\r\n    const code = body.charCodeAt(position); // LineTerminator (\\n | \\r)\r\n\r\n    if (code === 0x000a || code === 0x000d) {\r\n      break;\r\n    } // SourceCharacter\r\n\r\n    if (isUnicodeScalarValue(code)) {\r\n      ++position;\r\n    } else if (isSupplementaryCodePoint(body, position)) {\r\n      position += 2;\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return createToken(\r\n    lexer,\r\n    TokenKind.COMMENT,\r\n    start,\r\n    position,\r\n    body.slice(start + 1, position),\r\n  );\r\n}\r\n/**\r\n * Reads a number token from the source file, either a FloatValue or an IntValue\r\n * depending on whether a FractionalPart or ExponentPart is encountered.\r\n *\r\n * ```\r\n * IntValue :: IntegerPart [lookahead != {Digit, `.`, NameStart}]\r\n *\r\n * IntegerPart ::\r\n *   - NegativeSign? 0\r\n *   - NegativeSign? NonZeroDigit Digit*\r\n *\r\n * NegativeSign :: -\r\n *\r\n * NonZeroDigit :: Digit but not `0`\r\n *\r\n * FloatValue ::\r\n *   - IntegerPart FractionalPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\r\n *   - IntegerPart FractionalPart [lookahead != {Digit, `.`, NameStart}]\r\n *   - IntegerPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\r\n *\r\n * FractionalPart :: . Digit+\r\n *\r\n * ExponentPart :: ExponentIndicator Sign? Digit+\r\n *\r\n * ExponentIndicator :: one of `e` `E`\r\n *\r\n * Sign :: one of + -\r\n * ```\r\n */\r\n\r\nfunction readNumber(lexer, start, firstCode) {\r\n  const body = lexer.source.body;\r\n  let position = start;\r\n  let code = firstCode;\r\n  let isFloat = false; // NegativeSign (-)\r\n\r\n  if (code === 0x002d) {\r\n    code = body.charCodeAt(++position);\r\n  } // Zero (0)\r\n\r\n  if (code === 0x0030) {\r\n    code = body.charCodeAt(++position);\r\n\r\n    if (isDigit(code)) {\r\n      throw syntaxError(\r\n        lexer.source,\r\n        position,\r\n        `Invalid number, unexpected digit after 0: ${printCodePointAt(\r\n          lexer,\r\n          position,\r\n        )}.`,\r\n      );\r\n    }\r\n  } else {\r\n    position = readDigits(lexer, position, code);\r\n    code = body.charCodeAt(position);\r\n  } // Full stop (.)\r\n\r\n  if (code === 0x002e) {\r\n    isFloat = true;\r\n    code = body.charCodeAt(++position);\r\n    position = readDigits(lexer, position, code);\r\n    code = body.charCodeAt(position);\r\n  } // E e\r\n\r\n  if (code === 0x0045 || code === 0x0065) {\r\n    isFloat = true;\r\n    code = body.charCodeAt(++position); // + -\r\n\r\n    if (code === 0x002b || code === 0x002d) {\r\n      code = body.charCodeAt(++position);\r\n    }\r\n\r\n    position = readDigits(lexer, position, code);\r\n    code = body.charCodeAt(position);\r\n  } // Numbers cannot be followed by . or NameStart\r\n\r\n  if (code === 0x002e || isNameStart(code)) {\r\n    throw syntaxError(\r\n      lexer.source,\r\n      position,\r\n      `Invalid number, expected digit but got: ${printCodePointAt(\r\n        lexer,\r\n        position,\r\n      )}.`,\r\n    );\r\n  }\r\n\r\n  return createToken(\r\n    lexer,\r\n    isFloat ? TokenKind.FLOAT : TokenKind.INT,\r\n    start,\r\n    position,\r\n    body.slice(start, position),\r\n  );\r\n}\r\n/**\r\n * Returns the new position in the source after reading one or more digits.\r\n */\r\n\r\nfunction readDigits(lexer, start, firstCode) {\r\n  if (!isDigit(firstCode)) {\r\n    throw syntaxError(\r\n      lexer.source,\r\n      start,\r\n      `Invalid number, expected digit but got: ${printCodePointAt(\r\n        lexer,\r\n        start,\r\n      )}.`,\r\n    );\r\n  }\r\n\r\n  const body = lexer.source.body;\r\n  let position = start + 1; // +1 to skip first firstCode\r\n\r\n  while (isDigit(body.charCodeAt(position))) {\r\n    ++position;\r\n  }\r\n\r\n  return position;\r\n}\r\n/**\r\n * Reads a single-quote string token from the source file.\r\n *\r\n * ```\r\n * StringValue ::\r\n *   - `\"\"` [lookahead != `\"`]\r\n *   - `\"` StringCharacter+ `\"`\r\n *\r\n * StringCharacter ::\r\n *   - SourceCharacter but not `\"` or `\\` or LineTerminator\r\n *   - `\\u` EscapedUnicode\r\n *   - `\\` EscapedCharacter\r\n *\r\n * EscapedUnicode ::\r\n *   - `{` HexDigit+ `}`\r\n *   - HexDigit HexDigit HexDigit HexDigit\r\n *\r\n * EscapedCharacter :: one of `\"` `\\` `/` `b` `f` `n` `r` `t`\r\n * ```\r\n */\r\n\r\nfunction readString(lexer, start) {\r\n  const body = lexer.source.body;\r\n  const bodyLength = body.length;\r\n  let position = start + 1;\r\n  let chunkStart = position;\r\n  let value = '';\r\n\r\n  while (position < bodyLength) {\r\n    const code = body.charCodeAt(position); // Closing Quote (\")\r\n\r\n    if (code === 0x0022) {\r\n      value += body.slice(chunkStart, position);\r\n      return createToken(lexer, TokenKind.STRING, start, position + 1, value);\r\n    } // Escape Sequence (\\)\r\n\r\n    if (code === 0x005c) {\r\n      value += body.slice(chunkStart, position);\r\n      const escape =\r\n        body.charCodeAt(position + 1) === 0x0075 // u\r\n          ? body.charCodeAt(position + 2) === 0x007b // {\r\n            ? readEscapedUnicodeVariableWidth(lexer, position)\r\n            : readEscapedUnicodeFixedWidth(lexer, position)\r\n          : readEscapedCharacter(lexer, position);\r\n      value += escape.value;\r\n      position += escape.size;\r\n      chunkStart = position;\r\n      continue;\r\n    } // LineTerminator (\\n | \\r)\r\n\r\n    if (code === 0x000a || code === 0x000d) {\r\n      break;\r\n    } // SourceCharacter\r\n\r\n    if (isUnicodeScalarValue(code)) {\r\n      ++position;\r\n    } else if (isSupplementaryCodePoint(body, position)) {\r\n      position += 2;\r\n    } else {\r\n      throw syntaxError(\r\n        lexer.source,\r\n        position,\r\n        `Invalid character within String: ${printCodePointAt(\r\n          lexer,\r\n          position,\r\n        )}.`,\r\n      );\r\n    }\r\n  }\r\n\r\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\r\n} // The string value and lexed size of an escape sequence.\r\n\r\nfunction readEscapedUnicodeVariableWidth(lexer, position) {\r\n  const body = lexer.source.body;\r\n  let point = 0;\r\n  let size = 3; // Cannot be larger than 12 chars (\\u{00000000}).\r\n\r\n  while (size < 12) {\r\n    const code = body.charCodeAt(position + size++); // Closing Brace (})\r\n\r\n    if (code === 0x007d) {\r\n      // Must be at least 5 chars (\\u{0}) and encode a Unicode scalar value.\r\n      if (size < 5 || !isUnicodeScalarValue(point)) {\r\n        break;\r\n      }\r\n\r\n      return {\r\n        value: String.fromCodePoint(point),\r\n        size,\r\n      };\r\n    } // Append this hex digit to the code point.\r\n\r\n    point = (point << 4) | readHexDigit(code);\r\n\r\n    if (point < 0) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  throw syntaxError(\r\n    lexer.source,\r\n    position,\r\n    `Invalid Unicode escape sequence: \"${body.slice(\r\n      position,\r\n      position + size,\r\n    )}\".`,\r\n  );\r\n}\r\n\r\nfunction readEscapedUnicodeFixedWidth(lexer, position) {\r\n  const body = lexer.source.body;\r\n  const code = read16BitHexCode(body, position + 2);\r\n\r\n  if (isUnicodeScalarValue(code)) {\r\n    return {\r\n      value: String.fromCodePoint(code),\r\n      size: 6,\r\n    };\r\n  } // GraphQL allows JSON-style surrogate pair escape sequences, but only when\r\n  // a valid pair is formed.\r\n\r\n  if (isLeadingSurrogate(code)) {\r\n    // \\u\r\n    if (\r\n      body.charCodeAt(position + 6) === 0x005c &&\r\n      body.charCodeAt(position + 7) === 0x0075\r\n    ) {\r\n      const trailingCode = read16BitHexCode(body, position + 8);\r\n\r\n      if (isTrailingSurrogate(trailingCode)) {\r\n        // JavaScript defines strings as a sequence of UTF-16 code units and\r\n        // encodes Unicode code points above U+FFFF using a surrogate pair of\r\n        // code units. Since this is a surrogate pair escape sequence, just\r\n        // include both codes into the JavaScript string value. Had JavaScript\r\n        // not been internally based on UTF-16, then this surrogate pair would\r\n        // be decoded to retrieve the supplementary code point.\r\n        return {\r\n          value: String.fromCodePoint(code, trailingCode),\r\n          size: 12,\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  throw syntaxError(\r\n    lexer.source,\r\n    position,\r\n    `Invalid Unicode escape sequence: \"${body.slice(position, position + 6)}\".`,\r\n  );\r\n}\r\n/**\r\n * Reads four hexadecimal characters and returns the positive integer that 16bit\r\n * hexadecimal string represents. For example, \"000f\" will return 15, and \"dead\"\r\n * will return 57005.\r\n *\r\n * Returns a negative number if any char was not a valid hexadecimal digit.\r\n */\r\n\r\nfunction read16BitHexCode(body, position) {\r\n  // readHexDigit() returns -1 on error. ORing a negative value with any other\r\n  // value always produces a negative value.\r\n  return (\r\n    (readHexDigit(body.charCodeAt(position)) << 12) |\r\n    (readHexDigit(body.charCodeAt(position + 1)) << 8) |\r\n    (readHexDigit(body.charCodeAt(position + 2)) << 4) |\r\n    readHexDigit(body.charCodeAt(position + 3))\r\n  );\r\n}\r\n/**\r\n * Reads a hexadecimal character and returns its positive integer value (0-15).\r\n *\r\n * '0' becomes 0, '9' becomes 9\r\n * 'A' becomes 10, 'F' becomes 15\r\n * 'a' becomes 10, 'f' becomes 15\r\n *\r\n * Returns -1 if the provided character code was not a valid hexadecimal digit.\r\n *\r\n * HexDigit :: one of\r\n *   - `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\r\n *   - `A` `B` `C` `D` `E` `F`\r\n *   - `a` `b` `c` `d` `e` `f`\r\n */\r\n\r\nfunction readHexDigit(code) {\r\n  return code >= 0x0030 && code <= 0x0039 // 0-9\r\n    ? code - 0x0030\r\n    : code >= 0x0041 && code <= 0x0046 // A-F\r\n    ? code - 0x0037\r\n    : code >= 0x0061 && code <= 0x0066 // a-f\r\n    ? code - 0x0057\r\n    : -1;\r\n}\r\n/**\r\n * | Escaped Character | Code Point | Character Name               |\r\n * | ----------------- | ---------- | ---------------------------- |\r\n * | `\"`               | U+0022     | double quote                 |\r\n * | `\\`               | U+005C     | reverse solidus (back slash) |\r\n * | `/`               | U+002F     | solidus (forward slash)      |\r\n * | `b`               | U+0008     | backspace                    |\r\n * | `f`               | U+000C     | form feed                    |\r\n * | `n`               | U+000A     | line feed (new line)         |\r\n * | `r`               | U+000D     | carriage return              |\r\n * | `t`               | U+0009     | horizontal tab               |\r\n */\r\n\r\nfunction readEscapedCharacter(lexer, position) {\r\n  const body = lexer.source.body;\r\n  const code = body.charCodeAt(position + 1);\r\n\r\n  switch (code) {\r\n    case 0x0022:\r\n      // \"\r\n      return {\r\n        value: '\\u0022',\r\n        size: 2,\r\n      };\r\n\r\n    case 0x005c:\r\n      // \\\r\n      return {\r\n        value: '\\u005c',\r\n        size: 2,\r\n      };\r\n\r\n    case 0x002f:\r\n      // /\r\n      return {\r\n        value: '\\u002f',\r\n        size: 2,\r\n      };\r\n\r\n    case 0x0062:\r\n      // b\r\n      return {\r\n        value: '\\u0008',\r\n        size: 2,\r\n      };\r\n\r\n    case 0x0066:\r\n      // f\r\n      return {\r\n        value: '\\u000c',\r\n        size: 2,\r\n      };\r\n\r\n    case 0x006e:\r\n      // n\r\n      return {\r\n        value: '\\u000a',\r\n        size: 2,\r\n      };\r\n\r\n    case 0x0072:\r\n      // r\r\n      return {\r\n        value: '\\u000d',\r\n        size: 2,\r\n      };\r\n\r\n    case 0x0074:\r\n      // t\r\n      return {\r\n        value: '\\u0009',\r\n        size: 2,\r\n      };\r\n  }\r\n\r\n  throw syntaxError(\r\n    lexer.source,\r\n    position,\r\n    `Invalid character escape sequence: \"${body.slice(\r\n      position,\r\n      position + 2,\r\n    )}\".`,\r\n  );\r\n}\r\n/**\r\n * Reads a block string token from the source file.\r\n *\r\n * ```\r\n * StringValue ::\r\n *   - `\"\"\"` BlockStringCharacter* `\"\"\"`\r\n *\r\n * BlockStringCharacter ::\r\n *   - SourceCharacter but not `\"\"\"` or `\\\"\"\"`\r\n *   - `\\\"\"\"`\r\n * ```\r\n */\r\n\r\nfunction readBlockString(lexer, start) {\r\n  const body = lexer.source.body;\r\n  const bodyLength = body.length;\r\n  let lineStart = lexer.lineStart;\r\n  let position = start + 3;\r\n  let chunkStart = position;\r\n  let currentLine = '';\r\n  const blockLines = [];\r\n\r\n  while (position < bodyLength) {\r\n    const code = body.charCodeAt(position); // Closing Triple-Quote (\"\"\")\r\n\r\n    if (\r\n      code === 0x0022 &&\r\n      body.charCodeAt(position + 1) === 0x0022 &&\r\n      body.charCodeAt(position + 2) === 0x0022\r\n    ) {\r\n      currentLine += body.slice(chunkStart, position);\r\n      blockLines.push(currentLine);\r\n      const token = createToken(\r\n        lexer,\r\n        TokenKind.BLOCK_STRING,\r\n        start,\r\n        position + 3, // Return a string of the lines joined with U+000A.\r\n        dedentBlockStringLines(blockLines).join('\\n'),\r\n      );\r\n      lexer.line += blockLines.length - 1;\r\n      lexer.lineStart = lineStart;\r\n      return token;\r\n    } // Escaped Triple-Quote (\\\"\"\")\r\n\r\n    if (\r\n      code === 0x005c &&\r\n      body.charCodeAt(position + 1) === 0x0022 &&\r\n      body.charCodeAt(position + 2) === 0x0022 &&\r\n      body.charCodeAt(position + 3) === 0x0022\r\n    ) {\r\n      currentLine += body.slice(chunkStart, position);\r\n      chunkStart = position + 1; // skip only slash\r\n\r\n      position += 4;\r\n      continue;\r\n    } // LineTerminator\r\n\r\n    if (code === 0x000a || code === 0x000d) {\r\n      currentLine += body.slice(chunkStart, position);\r\n      blockLines.push(currentLine);\r\n\r\n      if (code === 0x000d && body.charCodeAt(position + 1) === 0x000a) {\r\n        position += 2;\r\n      } else {\r\n        ++position;\r\n      }\r\n\r\n      currentLine = '';\r\n      chunkStart = position;\r\n      lineStart = position;\r\n      continue;\r\n    } // SourceCharacter\r\n\r\n    if (isUnicodeScalarValue(code)) {\r\n      ++position;\r\n    } else if (isSupplementaryCodePoint(body, position)) {\r\n      position += 2;\r\n    } else {\r\n      throw syntaxError(\r\n        lexer.source,\r\n        position,\r\n        `Invalid character within String: ${printCodePointAt(\r\n          lexer,\r\n          position,\r\n        )}.`,\r\n      );\r\n    }\r\n  }\r\n\r\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\r\n}\r\n/**\r\n * Reads an alphanumeric + underscore name from the source.\r\n *\r\n * ```\r\n * Name ::\r\n *   - NameStart NameContinue* [lookahead != NameContinue]\r\n * ```\r\n */\r\n\r\nfunction readName(lexer, start) {\r\n  const body = lexer.source.body;\r\n  const bodyLength = body.length;\r\n  let position = start + 1;\r\n\r\n  while (position < bodyLength) {\r\n    const code = body.charCodeAt(position);\r\n\r\n    if (isNameContinue(code)) {\r\n      ++position;\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n\r\n  return createToken(\r\n    lexer,\r\n    TokenKind.NAME,\r\n    start,\r\n    position,\r\n    body.slice(start, position),\r\n  );\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}