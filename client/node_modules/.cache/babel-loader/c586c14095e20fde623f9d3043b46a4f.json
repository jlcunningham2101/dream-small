{"ast":null,"code":"import find from \"../polyfills/find.mjs\";\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { locatedError } from \"../error/locatedError.mjs\";\nimport { isValidNameError } from \"../utilities/assertValidName.mjs\";\nimport { isEqualType, isTypeSubTypeOf } from \"../utilities/typeComparators.mjs\";\nimport { assertSchema } from \"./schema.mjs\";\nimport { isIntrospectionType } from \"./introspection.mjs\";\nimport { isDirective, GraphQLDeprecatedDirective } from \"./directives.mjs\";\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNamedType, isNonNullType, isInputType, isOutputType, isRequiredArgument, isRequiredInputField } from \"./definition.mjs\";\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\nvar SchemaValidationContext = /*#__PURE__*/function () {\n  function SchemaValidationContext(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  var _proto = SchemaValidationContext.prototype;\n\n  _proto.reportError = function reportError(message, nodes) {\n    var _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this.addError(new GraphQLError(message, _nodes));\n  };\n\n  _proto.addError = function addError(error) {\n    this._errors.push(error);\n  };\n\n  _proto.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  return SchemaValidationContext;\n}();\n\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    var _getOperationTypeNode;\n\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType), \".\"), (_getOperationTypeNode = getOperationTypeNode(schema, 'query')) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    var _getOperationTypeNode2;\n\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(mutationType), \".\"), (_getOperationTypeNode2 = getOperationTypeNode(schema, 'mutation')) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    var _getOperationTypeNode3;\n\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(subscriptionType), \".\"), (_getOperationTypeNode3 = getOperationTypeNode(schema, 'subscription')) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);\n  }\n}\n\nfunction getOperationTypeNode(schema, operation) {\n  var operationNodes = getAllSubNodes(schema, function (node) {\n    return node.operationTypes;\n  });\n\n  for (var _i2 = 0; _i2 < operationNodes.length; _i2++) {\n    var node = operationNodes[_i2];\n\n    if (node.operation === operation) {\n      return node.type;\n    }\n  }\n\n  return undefined;\n}\n\nfunction validateDirectives(context) {\n  for (var _i4 = 0, _context$schema$getDi2 = context.schema.getDirectives(); _i4 < _context$schema$getDi2.length; _i4++) {\n    var directive = _context$schema$getDi2[_i4]; // Ensure all directives are in fact GraphQL directives.\n\n    if (!isDirective(directive)) {\n      context.reportError(\"Expected directive but got: \".concat(inspect(directive), \".\"), directive === null || directive === void 0 ? void 0 : directive.astNode);\n      continue;\n    } // Ensure they are named correctly.\n\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {\n      var arg = _directive$args2[_i6]; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(arg.name, \":) must be Input Type \") + \"but got: \".concat(inspect(arg.type), \".\"), arg.astNode);\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode;\n\n        context.reportError(\"Required argument @\".concat(directive.name, \"(\").concat(arg.name, \":) cannot be deprecated.\"), [getDeprecatedDirectiveNode(arg.astNode), // istanbul ignore next (TODO need to write coverage tests)\n        (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type]);\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  var error = isValidNameError(node.name);\n\n  if (error) {\n    context.addError(locatedError(error, node.astNode));\n  }\n}\n\nfunction validateTypes(context) {\n  var validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  var typeMap = context.schema.getTypeMap();\n\n  for (var _i8 = 0, _objectValues2 = objectValues(typeMap); _i8 < _objectValues2.length; _i8++) {\n    var type = _objectValues2[_i8]; // Ensure all provided types are in fact GraphQL type.\n\n    if (!isNamedType(type)) {\n      context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type), \".\"), type.astNode);\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  var fields = objectValues(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), getAllNodes(type));\n  }\n\n  for (var _i10 = 0; _i10 < fields.length; _i10++) {\n    var field = fields[_i10]; // Ensure they are named correctly.\n\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      var _field$astNode;\n\n      context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat(inspect(field.type), \".\"), (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);\n    } // Ensure the arguments are valid\n\n\n    for (var _i12 = 0, _field$args2 = field.args; _i12 < _field$args2.length; _i12++) {\n      var arg = _field$args2[_i12];\n      var argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        var _arg$astNode2;\n\n        context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat(inspect(arg.type), \".\"), (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode3;\n\n        context.reportError(\"Required argument \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) cannot be deprecated.\"), [getDeprecatedDirectiveNode(arg.astNode), // istanbul ignore next (TODO need to write coverage tests)\n        (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type]);\n      }\n    }\n  }\n}\n\nfunction validateInterfaces(context, type) {\n  var ifaceTypeNames = Object.create(null);\n\n  for (var _i14 = 0, _type$getInterfaces2 = type.getInterfaces(); _i14 < _type$getInterfaces2.length; _i14++) {\n    var iface = _type$getInterfaces2[_i14];\n\n    if (!isInterfaceType(iface)) {\n      context.reportError(\"Type \".concat(inspect(type), \" must only implement Interface types, \") + \"it cannot implement \".concat(inspect(iface), \".\"), getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(\"Type \".concat(type.name, \" cannot implement itself because it would create a circular reference.\"), getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(\"Type \".concat(type.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(context, type, iface) {\n  var typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (var _i16 = 0, _objectValues4 = objectValues(iface.getFields()); _i16 < _objectValues4.length; _i16++) {\n    var ifaceField = _objectValues4[_i16];\n    var fieldName = ifaceField.name;\n    var typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \").concat(type.name, \" does not provide it.\"), [ifaceField.astNode].concat(getAllNodes(type)));\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat(inspect(ifaceField.type), \" but \").concat(type.name, \".\").concat(fieldName, \" \") + \"is type \".concat(inspect(typeField.type), \".\"), [// istanbul ignore next (TODO need to write coverage tests)\n      (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type, // istanbul ignore next (TODO need to write coverage tests)\n      (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type]);\n    } // Assert each interface field arg is implemented.\n\n\n    var _loop = function _loop(_i18, _ifaceField$args2) {\n      var ifaceArg = _ifaceField$args2[_i18];\n      var argName = ifaceArg.name;\n      var typeArg = find(typeField.args, function (arg) {\n        return arg.name === argName;\n      }); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) expected but \").concat(type.name, \".\").concat(fieldName, \" does not provide it.\"), [ifaceArg.astNode, typeField.astNode]);\n        return \"continue\";\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat(inspect(ifaceArg.type), \" but \") + \"\".concat(type.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat(inspect(typeArg.type), \".\"), [// istanbul ignore next (TODO need to write coverage tests)\n        (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type, // istanbul ignore next (TODO need to write coverage tests)\n        (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type]);\n      } // TODO: validate default values?\n\n    };\n\n    for (var _i18 = 0, _ifaceField$args2 = ifaceField.args; _i18 < _ifaceField$args2.length; _i18++) {\n      var _ret = _loop(_i18, _ifaceField$args2);\n\n      if (_ret === \"continue\") continue;\n    } // Assert additional arguments must not be required.\n\n\n    var _loop2 = function _loop2(_i20, _typeField$args2) {\n      var typeArg = _typeField$args2[_i20];\n      var argName = typeArg.name;\n      var ifaceArg = find(ifaceField.args, function (arg) {\n        return arg.name === argName;\n      });\n\n      if (!ifaceArg && isRequiredArgument(typeArg)) {\n        context.reportError(\"Object field \".concat(type.name, \".\").concat(fieldName, \" includes required argument \").concat(argName, \" that is missing from the Interface field \").concat(iface.name, \".\").concat(fieldName, \".\"), [typeArg.astNode, ifaceField.astNode]);\n      }\n    };\n\n    for (var _i20 = 0, _typeField$args2 = typeField.args; _i20 < _typeField$args2.length; _i20++) {\n      _loop2(_i20, _typeField$args2);\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  var ifaceInterfaces = type.getInterfaces();\n\n  for (var _i22 = 0, _iface$getInterfaces2 = iface.getInterfaces(); _i22 < _iface$getInterfaces2.length; _i22++) {\n    var transitive = _iface$getInterfaces2[_i22];\n\n    if (ifaceInterfaces.indexOf(transitive) === -1) {\n      context.reportError(transitive === type ? \"Type \".concat(type.name, \" cannot implement \").concat(iface.name, \" because it would create a circular reference.\") : \"Type \".concat(type.name, \" must implement \").concat(transitive.name, \" because it is implemented by \").concat(iface.name, \".\"), [].concat(getAllImplementsInterfaceNodes(iface, transitive), getAllImplementsInterfaceNodes(type, iface)));\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), getAllNodes(union));\n  }\n\n  var includedTypeNames = Object.create(null);\n\n  for (var _i24 = 0; _i24 < memberTypes.length; _i24++) {\n    var memberType = memberTypes[_i24];\n\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include type \").concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!isObjectType(memberType)) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat(inspect(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), getAllNodes(enumType));\n  }\n\n  for (var _i26 = 0; _i26 < enumValues.length; _i26++) {\n    var enumValue = enumValues[_i26];\n    var valueName = enumValue.name; // Ensure valid name.\n\n    validateName(context, enumValue);\n\n    if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n      context.reportError(\"Enum type \".concat(enumType.name, \" cannot include value: \").concat(valueName, \".\"), enumValue.astNode);\n    }\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  var fields = objectValues(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), getAllNodes(inputObj));\n  } // Ensure the arguments are valid\n\n\n  for (var _i28 = 0; _i28 < fields.length; _i28++) {\n    var field = fields[_i28]; // Ensure they are named correctly.\n\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      var _field$astNode2;\n\n      context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat(inspect(field.type), \".\"), (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);\n    }\n\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n\n      context.reportError(\"Required input field \".concat(inputObj.name, \".\").concat(field.name, \" cannot be deprecated.\"), [getDeprecatedDirectiveNode(field.astNode), // istanbul ignore next (TODO need to write coverage tests)\n      (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type]);\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  var fieldPath = []; // Position in the type path\n\n  var fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    var fields = objectValues(inputObj.getFields());\n\n    for (var _i30 = 0; _i30 < fields.length; _i30++) {\n      var field = fields[_i30];\n\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        var fieldType = field.type.ofType;\n        var cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          var cyclePath = fieldPath.slice(cycleIndex);\n          var pathStr = cyclePath.map(function (fieldObj) {\n            return fieldObj.name;\n          }).join('.');\n          context.reportError(\"Cannot reference Input Object \\\"\".concat(fieldType.name, \"\\\" within itself through a series of non-null fields: \\\"\").concat(pathStr, \"\\\".\"), cyclePath.map(function (fieldObj) {\n            return fieldObj.astNode;\n          }));\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllNodes(object) {\n  var astNode = object.astNode,\n      extensionASTNodes = object.extensionASTNodes;\n  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes !== null && extensionASTNodes !== void 0 ? extensionASTNodes : [];\n}\n\nfunction getAllSubNodes(object, getter) {\n  var subNodes = [];\n\n  for (var _i32 = 0, _getAllNodes2 = getAllNodes(object); _i32 < _getAllNodes2.length; _i32++) {\n    var _getter;\n\n    var node = _getAllNodes2[_i32]; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n    subNodes = subNodes.concat((_getter = getter(node)) !== null && _getter !== void 0 ? _getter : []);\n  }\n\n  return subNodes;\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.interfaces;\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return getAllSubNodes(union, function (unionNode) {\n    return unionNode.types;\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}\n\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n\n\n  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(function (node) {\n    return node.name.value === GraphQLDeprecatedDirective.name;\n  });\n}","map":{"version":3,"names":["find","objectValues","inspect","GraphQLError","locatedError","isValidNameError","isEqualType","isTypeSubTypeOf","assertSchema","isIntrospectionType","isDirective","GraphQLDeprecatedDirective","isObjectType","isInterfaceType","isUnionType","isEnumType","isInputObjectType","isNamedType","isNonNullType","isInputType","isOutputType","isRequiredArgument","isRequiredInputField","validateSchema","schema","__validationErrors","context","SchemaValidationContext","validateRootTypes","validateDirectives","validateTypes","errors","getErrors","assertValidSchema","length","Error","map","error","message","join","_errors","_proto","prototype","reportError","nodes","_nodes","Array","isArray","filter","Boolean","addError","push","queryType","getQueryType","astNode","_getOperationTypeNode","concat","getOperationTypeNode","mutationType","getMutationType","_getOperationTypeNode2","subscriptionType","getSubscriptionType","_getOperationTypeNode3","operation","operationNodes","getAllSubNodes","node","operationTypes","_i2","type","undefined","_i4","_context$schema$getDi2","getDirectives","directive","validateName","_i6","_directive$args2","args","arg","name","deprecationReason","_arg$astNode","getDeprecatedDirectiveNode","validateInputObjectCircularRefs","createInputObjectCircularRefsValidator","typeMap","getTypeMap","_i8","_objectValues2","validateFields","validateInterfaces","validateUnionMembers","validateEnumValues","validateInputFields","fields","getFields","getAllNodes","_i10","field","_field$astNode","_i12","_field$args2","argName","_arg$astNode2","_arg$astNode3","ifaceTypeNames","Object","create","_i14","_type$getInterfaces2","getInterfaces","iface","getAllImplementsInterfaceNodes","validateTypeImplementsAncestors","validateTypeImplementsInterface","typeFieldMap","_i16","_objectValues4","ifaceField","fieldName","typeField","_ifaceField$astNode","_typeField$astNode","_loop","_i18","_ifaceField$args2","ifaceArg","typeArg","_ifaceArg$astNode","_typeArg$astNode","_ret","_loop2","_i20","_typeField$args2","ifaceInterfaces","_i22","_iface$getInterfaces2","transitive","indexOf","union","memberTypes","getTypes","includedTypeNames","_i24","memberType","getUnionMemberTypeNodes","String","enumType","enumValues","getValues","_i26","enumValue","valueName","inputObj","_i28","_field$astNode2","_field$astNode3","visitedTypes","fieldPath","fieldPathIndexByTypeName","detectCycleRecursive","_i30","ofType","fieldType","cycleIndex","cyclePath","slice","pathStr","fieldObj","pop","object","extensionASTNodes","getter","subNodes","_i32","_getAllNodes2","_getter","typeNode","interfaces","ifaceNode","value","typeName","unionNode","types","definitionNode","_definitionNode$direc","directives"],"sources":["C:/Users/jleig/Desktop/challenges/dream-small/client/node_modules/graphql/type/validate.mjs"],"sourcesContent":["import find from \"../polyfills/find.mjs\";\nimport objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport { GraphQLError } from \"../error/GraphQLError.mjs\";\nimport { locatedError } from \"../error/locatedError.mjs\";\nimport { isValidNameError } from \"../utilities/assertValidName.mjs\";\nimport { isEqualType, isTypeSubTypeOf } from \"../utilities/typeComparators.mjs\";\nimport { assertSchema } from \"./schema.mjs\";\nimport { isIntrospectionType } from \"./introspection.mjs\";\nimport { isDirective, GraphQLDeprecatedDirective } from \"./directives.mjs\";\nimport { isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, isNamedType, isNonNullType, isInputType, isOutputType, isRequiredArgument, isRequiredInputField } from \"./definition.mjs\";\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\n\nvar SchemaValidationContext = /*#__PURE__*/function () {\n  function SchemaValidationContext(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  var _proto = SchemaValidationContext.prototype;\n\n  _proto.reportError = function reportError(message, nodes) {\n    var _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this.addError(new GraphQLError(message, _nodes));\n  };\n\n  _proto.addError = function addError(error) {\n    this._errors.push(error);\n  };\n\n  _proto.getErrors = function getErrors() {\n    return this._errors;\n  };\n\n  return SchemaValidationContext;\n}();\n\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    var _getOperationTypeNode;\n\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType), \".\"), (_getOperationTypeNode = getOperationTypeNode(schema, 'query')) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);\n  }\n\n  var mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    var _getOperationTypeNode2;\n\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(mutationType), \".\"), (_getOperationTypeNode2 = getOperationTypeNode(schema, 'mutation')) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);\n  }\n\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    var _getOperationTypeNode3;\n\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(subscriptionType), \".\"), (_getOperationTypeNode3 = getOperationTypeNode(schema, 'subscription')) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);\n  }\n}\n\nfunction getOperationTypeNode(schema, operation) {\n  var operationNodes = getAllSubNodes(schema, function (node) {\n    return node.operationTypes;\n  });\n\n  for (var _i2 = 0; _i2 < operationNodes.length; _i2++) {\n    var node = operationNodes[_i2];\n\n    if (node.operation === operation) {\n      return node.type;\n    }\n  }\n\n  return undefined;\n}\n\nfunction validateDirectives(context) {\n  for (var _i4 = 0, _context$schema$getDi2 = context.schema.getDirectives(); _i4 < _context$schema$getDi2.length; _i4++) {\n    var directive = _context$schema$getDi2[_i4];\n\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(\"Expected directive but got: \".concat(inspect(directive), \".\"), directive === null || directive === void 0 ? void 0 : directive.astNode);\n      continue;\n    } // Ensure they are named correctly.\n\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {\n      var arg = _directive$args2[_i6];\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(arg.name, \":) must be Input Type \") + \"but got: \".concat(inspect(arg.type), \".\"), arg.astNode);\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode;\n\n        context.reportError(\"Required argument @\".concat(directive.name, \"(\").concat(arg.name, \":) cannot be deprecated.\"), [getDeprecatedDirectiveNode(arg.astNode), // istanbul ignore next (TODO need to write coverage tests)\n        (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type]);\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  var error = isValidNameError(node.name);\n\n  if (error) {\n    context.addError(locatedError(error, node.astNode));\n  }\n}\n\nfunction validateTypes(context) {\n  var validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  var typeMap = context.schema.getTypeMap();\n\n  for (var _i8 = 0, _objectValues2 = objectValues(typeMap); _i8 < _objectValues2.length; _i8++) {\n    var type = _objectValues2[_i8];\n\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type), \".\"), type.astNode);\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  var fields = objectValues(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), getAllNodes(type));\n  }\n\n  for (var _i10 = 0; _i10 < fields.length; _i10++) {\n    var field = fields[_i10];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      var _field$astNode;\n\n      context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat(inspect(field.type), \".\"), (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);\n    } // Ensure the arguments are valid\n\n\n    for (var _i12 = 0, _field$args2 = field.args; _i12 < _field$args2.length; _i12++) {\n      var arg = _field$args2[_i12];\n      var argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        var _arg$astNode2;\n\n        context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat(inspect(arg.type), \".\"), (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode3;\n\n        context.reportError(\"Required argument \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) cannot be deprecated.\"), [getDeprecatedDirectiveNode(arg.astNode), // istanbul ignore next (TODO need to write coverage tests)\n        (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type]);\n      }\n    }\n  }\n}\n\nfunction validateInterfaces(context, type) {\n  var ifaceTypeNames = Object.create(null);\n\n  for (var _i14 = 0, _type$getInterfaces2 = type.getInterfaces(); _i14 < _type$getInterfaces2.length; _i14++) {\n    var iface = _type$getInterfaces2[_i14];\n\n    if (!isInterfaceType(iface)) {\n      context.reportError(\"Type \".concat(inspect(type), \" must only implement Interface types, \") + \"it cannot implement \".concat(inspect(iface), \".\"), getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(\"Type \".concat(type.name, \" cannot implement itself because it would create a circular reference.\"), getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(\"Type \".concat(type.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(type, iface));\n      continue;\n    }\n\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(context, type, iface) {\n  var typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (var _i16 = 0, _objectValues4 = objectValues(iface.getFields()); _i16 < _objectValues4.length; _i16++) {\n    var ifaceField = _objectValues4[_i16];\n    var fieldName = ifaceField.name;\n    var typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \").concat(type.name, \" does not provide it.\"), [ifaceField.astNode].concat(getAllNodes(type)));\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat(inspect(ifaceField.type), \" but \").concat(type.name, \".\").concat(fieldName, \" \") + \"is type \".concat(inspect(typeField.type), \".\"), [// istanbul ignore next (TODO need to write coverage tests)\n      (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type, // istanbul ignore next (TODO need to write coverage tests)\n      (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type]);\n    } // Assert each interface field arg is implemented.\n\n\n    var _loop = function _loop(_i18, _ifaceField$args2) {\n      var ifaceArg = _ifaceField$args2[_i18];\n      var argName = ifaceArg.name;\n      var typeArg = find(typeField.args, function (arg) {\n        return arg.name === argName;\n      }); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) expected but \").concat(type.name, \".\").concat(fieldName, \" does not provide it.\"), [ifaceArg.astNode, typeField.astNode]);\n        return \"continue\";\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n\n        context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat(inspect(ifaceArg.type), \" but \") + \"\".concat(type.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat(inspect(typeArg.type), \".\"), [// istanbul ignore next (TODO need to write coverage tests)\n        (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type, // istanbul ignore next (TODO need to write coverage tests)\n        (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type]);\n      } // TODO: validate default values?\n\n    };\n\n    for (var _i18 = 0, _ifaceField$args2 = ifaceField.args; _i18 < _ifaceField$args2.length; _i18++) {\n      var _ret = _loop(_i18, _ifaceField$args2);\n\n      if (_ret === \"continue\") continue;\n    } // Assert additional arguments must not be required.\n\n\n    var _loop2 = function _loop2(_i20, _typeField$args2) {\n      var typeArg = _typeField$args2[_i20];\n      var argName = typeArg.name;\n      var ifaceArg = find(ifaceField.args, function (arg) {\n        return arg.name === argName;\n      });\n\n      if (!ifaceArg && isRequiredArgument(typeArg)) {\n        context.reportError(\"Object field \".concat(type.name, \".\").concat(fieldName, \" includes required argument \").concat(argName, \" that is missing from the Interface field \").concat(iface.name, \".\").concat(fieldName, \".\"), [typeArg.astNode, ifaceField.astNode]);\n      }\n    };\n\n    for (var _i20 = 0, _typeField$args2 = typeField.args; _i20 < _typeField$args2.length; _i20++) {\n      _loop2(_i20, _typeField$args2);\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  var ifaceInterfaces = type.getInterfaces();\n\n  for (var _i22 = 0, _iface$getInterfaces2 = iface.getInterfaces(); _i22 < _iface$getInterfaces2.length; _i22++) {\n    var transitive = _iface$getInterfaces2[_i22];\n\n    if (ifaceInterfaces.indexOf(transitive) === -1) {\n      context.reportError(transitive === type ? \"Type \".concat(type.name, \" cannot implement \").concat(iface.name, \" because it would create a circular reference.\") : \"Type \".concat(type.name, \" must implement \").concat(transitive.name, \" because it is implemented by \").concat(iface.name, \".\"), [].concat(getAllImplementsInterfaceNodes(iface, transitive), getAllImplementsInterfaceNodes(type, iface)));\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), getAllNodes(union));\n  }\n\n  var includedTypeNames = Object.create(null);\n\n  for (var _i24 = 0; _i24 < memberTypes.length; _i24++) {\n    var memberType = memberTypes[_i24];\n\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include type \").concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!isObjectType(memberType)) {\n      context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat(inspect(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), getAllNodes(enumType));\n  }\n\n  for (var _i26 = 0; _i26 < enumValues.length; _i26++) {\n    var enumValue = enumValues[_i26];\n    var valueName = enumValue.name; // Ensure valid name.\n\n    validateName(context, enumValue);\n\n    if (valueName === 'true' || valueName === 'false' || valueName === 'null') {\n      context.reportError(\"Enum type \".concat(enumType.name, \" cannot include value: \").concat(valueName, \".\"), enumValue.astNode);\n    }\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  var fields = objectValues(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), getAllNodes(inputObj));\n  } // Ensure the arguments are valid\n\n\n  for (var _i28 = 0; _i28 < fields.length; _i28++) {\n    var field = fields[_i28];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      var _field$astNode2;\n\n      context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat(inspect(field.type), \".\"), (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);\n    }\n\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n\n      context.reportError(\"Required input field \".concat(inputObj.name, \".\").concat(field.name, \" cannot be deprecated.\"), [getDeprecatedDirectiveNode(field.astNode), // istanbul ignore next (TODO need to write coverage tests)\n      (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type]);\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  var fieldPath = []; // Position in the type path\n\n  var fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    var fields = objectValues(inputObj.getFields());\n\n    for (var _i30 = 0; _i30 < fields.length; _i30++) {\n      var field = fields[_i30];\n\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        var fieldType = field.type.ofType;\n        var cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          var cyclePath = fieldPath.slice(cycleIndex);\n          var pathStr = cyclePath.map(function (fieldObj) {\n            return fieldObj.name;\n          }).join('.');\n          context.reportError(\"Cannot reference Input Object \\\"\".concat(fieldType.name, \"\\\" within itself through a series of non-null fields: \\\"\").concat(pathStr, \"\\\".\"), cyclePath.map(function (fieldObj) {\n            return fieldObj.astNode;\n          }));\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllNodes(object) {\n  var astNode = object.astNode,\n      extensionASTNodes = object.extensionASTNodes;\n  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes !== null && extensionASTNodes !== void 0 ? extensionASTNodes : [];\n}\n\nfunction getAllSubNodes(object, getter) {\n  var subNodes = [];\n\n  for (var _i32 = 0, _getAllNodes2 = getAllNodes(object); _i32 < _getAllNodes2.length; _i32++) {\n    var _getter;\n\n    var node = _getAllNodes2[_i32];\n    // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n    subNodes = subNodes.concat((_getter = getter(node)) !== null && _getter !== void 0 ? _getter : []);\n  }\n\n  return subNodes;\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  return getAllSubNodes(type, function (typeNode) {\n    return typeNode.interfaces;\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  return getAllSubNodes(union, function (unionNode) {\n    return unionNode.types;\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}\n\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n\n  // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2203')\n  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(function (node) {\n    return node.name.value === GraphQLDeprecatedDirective.name;\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}